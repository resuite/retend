@Title unique
@Description The `Unique` component ensures only one instance of a component exists across your entire application by name. DOM nodes are preserved and moved instead of being recreated, maintaining state like video playback or scroll position.

---

@Example 1
@Input Basic Unique component with a name.
import { Unique } from 'retend';

const App = () => {
  return (
    <div>
      <Unique name="my-unique-content">
        {() => <div>This content is unique!</div>}
      </Unique>
    </div>
  );
};
@Note The `name` prop uniquely identifies this component instance.
@Note The `children` prop must be a function that returns JSX.

---

@Example 2
@Input Multiple Unique components with the same name - only one renders.
import { Unique } from 'retend';

const App = () => {
  return (
    <div>
      <Unique name="shared">
        {() => <p>First instance</p>}
      </Unique>
      <Unique name="shared">
        {() => <p>Second instance</p>}
      </Unique>
    </div>
  );
};
@Note Only the second instance renders; DOM moves to the last location.

---

@Example 3
@Input Video player that persists across navigation.
import { Cell, Switch, Unique } from 'retend';

const VideoPlayer = () => {
  return (
    <Unique name="main-video">
      {() => (
        <video src="https://example.com/video.mp4" controls autoplay>
          Your browser does not support the video tag.
        </video>
      )}
    </Unique>
  );
};

const HomePage = () => {
  return (
    <div>
      <h1>Home</h1>
      <VideoPlayer />
    </div>
  );
};

const AboutPage = () => {
  return (
    <div>
      <h1>About</h1>
      <VideoPlayer />
    </div>
  );
};

const App = () => {
  const page = Cell.source('home');
  return (
    <div>
      {Switch(page, {
        home: HomePage,
        about: AboutPage,
      })}
    </div>
  );
};
@Note Video continues playing when switching pages.
@Note DOM element is moved, not recreated.

---

@Example 4
@Input Moving Unique component with If conditional.
import { Cell, If, Unique } from 'retend';

const UniqueContent = () => {
  return (
    <Unique name="movable-content">
      {() => <div>I move around!</div>}
    </Unique>
  );
};

const App = () => {
  const showInFirst = Cell.source(true);
  const toggle = () => {
    showInFirst.set(!showInFirst.get());
  };
  return (
    <div>
      <div>First: {If(showInFirst, UniqueContent)}</div>
      <div>Second: {If(!showInFirst, UniqueContent)}</div>
      <button type="button" onClick={toggle}>Toggle Position</button>
    </div>
  );
};
@Note Component moves between positions without recreating.

---

@Example 5
@Input Unique with setup effects that persist.
import { Cell, Switch, Unique, useSetupEffect } from 'retend';

const PersistentComponent = () => {
  useSetupEffect(() => {
    console.log('Setup called once');
    return () => {
      console.log('Cleanup called when completely removed');
    };
  });
  return <div>Persistent content</div>;
};

const UniqueWrapper = () => {
  return (
    <Unique name="persistent">
      {() => <PersistentComponent />}
    </Unique>
  );
};

const App = () => {
  const page = Cell.source('home');
  return (
    <div>
      {Switch(page, {
        home: () => (
          <div>
            Home: <UniqueWrapper />
          </div>
        ),
        about: () => (
          <div>
            About: <UniqueWrapper />
          </div>
        ),
      })}
    </div>
  );
};
@Note Setup effects run once and persist across location changes.

---

@Example 6
@Input Saving and restoring scroll position.
import { Unique } from 'retend';

const ScrollableArea = () => {
  return (
    <Unique
      name="scroll-area"
      onSave={(el) => ({ scrollTop: el.scrollTop })}
      onRestore={(el, data) => {
        el.scrollTop = data.scrollTop;
      }}
    >
      {() => (
        <div style={{ height: '400px', overflow: 'auto' }}>
          <p>Content line 1</p>
          <p>Content line 2</p>
          <p>Content line 3</p>
        </div>
      )}
    </Unique>
  );
};
@Note `onSave` captures custom state before moving.
@Note `onRestore` applies saved state at new location.

---

@Example 7
@Input Multiple unique components with different names.
import { Unique } from 'retend';

const App = () => {
  return (
    <div>
      <Unique name="header-video">
        {() => <video src="header.mp4" controls />}
      </Unique>
      <Unique name="main-content">
        {() => <div>Main content here</div>}
      </Unique>
      <Unique name="footer-widget">
        {() => <div>Footer widget</div>}
      </Unique>
    </div>
  );
};
@Note Each unique name creates a separate persistent instance.

---

@Example 8
@Input Using ref to access the Unique element.
import { Cell, Unique } from 'retend';

const App = () => {
  const uniqueRef = Cell.source(null);
  const logElement = () => {
    console.log(uniqueRef.get());
  };
  return (
    <div>
      <Unique name="with-ref" ref={uniqueRef}>
        {() => <div>Content with ref</div>}
      </Unique>
      <button type="button" onClick={logElement}>Log Element</button>
    </div>
  );
};
@Note `ref` provides access to the underlying DOM element.

---

@Example 9
@Input Unique component with custom attributes.
import { Unique } from 'retend';

const App = () => {
  return (
    <div>
      <Unique
        name="styled-unique"
        class="my-class"
        style={{ padding: '20px', border: '1px solid blue' }}
        data-test="unique-element"
      >
        {() => <div>Styled unique content</div>}
      </Unique>
    </div>
  );
};
@Note Additional props are applied to the wrapper element.

---

@Example 10
@Input Audio player persisting across routes.
import { Cell, Switch, Unique } from 'retend';

const AudioPlayer = () => {
  return (
    <Unique name="audio-player">
      {() => (
        <audio src="https://example.com/audio.mp3" controls autoplay>
          Your browser does not support the audio tag.
        </audio>
      )}
    </Unique>
  );
};

const App = () => {
  const route = Cell.source('home');
  return (
    <div>
      {Switch(route, {
        home: () => (
          <div>
            Home <AudioPlayer />
          </div>
        ),
        contact: () => (
          <div>
            Contact <AudioPlayer />
          </div>
        ),
      })}
    </div>
  );
};
@Note Audio continues playing when navigating between routes.

---

@Example 11
@Input Unique in a For loop with dynamic names.
import { Cell, For, Unique } from 'retend';

const App = () => {
  const items = Cell.source([
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
  ]);
  return (
    <div>
      {For(items, (item) => (
        <Unique name={`item-${item.id}`}>
          {() => <div>{item.name}</div>}
        </Unique>
      ))}
    </div>
  );
};
@Note Use unique names per item to preserve each independently.

---

@Example 12
@Input Saving form input state.
import { Unique } from 'retend';

const FormInput = () => {
  return (
    <Unique
      name="form-input"
      onSave={(el) => {
        const input = el.querySelector('input');
        return { value: input?.value || '' };
      }}
      onRestore={(el, data) => {
        const input = el.querySelector('input');
        if (input && data) {
          input.value = data.value;
        }
      }}
    >
      {() => <input type="text" placeholder="Enter text..." />}
    </Unique>
  );
};
@Note Input value is preserved when component moves.

---

@Example 13
@Input Unique component with nested components.
import { Cell, Unique, useSetupEffect } from 'retend';

const NestedComponent = () => {
  const count = Cell.source(0);
  useSetupEffect(() => {
    const interval = setInterval(() => {
      count.set(count.get() + 1);
    }, 1000);
    return () => clearInterval(interval);
  });
  return <div>Count: {count}</div>;
};

const App = () => {
  return (
    <Unique name="nested-unique">
      {() => <NestedComponent />}
    </Unique>
  );
};
@Note Nested components maintain their state and effects.

---

@Example 14
@Input Conditionally rendering Unique across different containers.
import { Cell, If, Unique } from 'retend';

const SharedContent = () => {
  return (
    <Unique name="shared-content">
      {() => <div>Shared across containers</div>}
    </Unique>
  );
};

const App = () => {
  const location = Cell.source('left');
  const moveRight = () => {
    location.set('right');
  };
  const moveLeft = () => {
    location.set('left');
  };
  return (
    <div style={{ display: 'flex', gap: '20px' }}>
      <div style={{ border: '1px solid red', padding: '10px' }}>
        Left: {If(location, (loc) => If(loc === 'left', SharedContent))}
      </div>
      <div style={{ border: '1px solid blue', padding: '10px' }}>
        Right: {If(location, (loc) => If(loc === 'right', SharedContent))}
      </div>
      <button type="button" onClick={moveLeft}>Move Left</button>
      <button type="button" onClick={moveRight}>Move Right</button>
    </div>
  );
};

---

@Example 15
@Input Saving complex state with multiple data points.
import { Unique } from 'retend';

const ComplexComponent = () => {
  return (
    <Unique
      name="complex"
      onSave={(el) => {
        return {
          timestamp: Date.now(),
          scrollTop: el.scrollTop,
          customData: 'preserved',
        };
      }}
      onRestore={(el, data) => {
        console.log('Restored at:', new Date(data.timestamp));
        el.scrollTop = data.scrollTop;
      }}
    >
      {() => (
        <div style={{ height: '300px', overflow: 'auto' }}>
          <p>Line 1</p>
          <p>Line 2</p>
        </div>
      )}
    </Unique>
  );
};
@Note onSave can return any custom data structure.

---

@Example 16
@Input Unique component with video and custom controls.
import { Cell, Unique } from 'retend';

const VideoWithControls = () => {
  const videoRef = Cell.source(null);
  const play = () => {
    videoRef.get()?.play();
  };
  const pause = () => {
    videoRef.get()?.pause();
  };
  return (
    <Unique name="video-controls">
      {() => (
        <div>
          <video ref={videoRef} src="video.mp4">
            Your browser does not support the video tag.
          </video>
          <button type="button" onClick={play}>Play</button>
          <button type="button" onClick={pause}>Pause</button>
        </div>
      )}
    </Unique>
  );
};
@Note Refs work inside Unique components.

---

@Example 17
@Input Unique modal that persists across pages.
import { Cell, Switch, Unique, If } from 'retend';

const Modal = () => {
  return (
    <Unique name="global-modal">
      {() => (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'white',
          padding: '20px',
          boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
        }}>
          <h2>Modal Content</h2>
          <p>This modal persists across page changes</p>
        </div>
      )}
    </Unique>
  );
};

const App = () => {
  const showModal = Cell.source(false);
  const page = Cell.source('home');
  const toggleModal = () => {
    showModal.set(!showModal.get());
  };
  return (
    <div>
      {Switch(page, {
        home: () => <div>Home Page</div>,
        about: () => <div>About Page</div>,
      })}
      {If(showModal, Modal)}
      <button type="button" onClick={toggleModal}>Toggle Modal</button>
    </div>
  );
};

---

@Example 18
@Input Unique component that only cleans up when fully removed.
import { Cell, If, Unique, useSetupEffect } from 'retend';

const ResourceComponent = () => {
  useSetupEffect(() => {
    console.log('Resource initialized');
    const resource = { connected: true };
    return () => {
      console.log('Resource cleaned up');
      resource.connected = false;
    };
  });
  return <div>Resource Component</div>;
};

const UniqueResource = () => {
  return (
    <Unique name="resource">
      {() => <ResourceComponent />}
    </Unique>
  );
};

const App = () => {
  const show = Cell.source(true);
  const toggle = () => {
    show.set(!show.get());
  };
  return (
    <div>
      {If(show, UniqueResource)}
      <button type="button" onClick={toggle}>Toggle</button>
    </div>
  );
};
@Note Cleanup only runs when all instances are removed.

---

@Example 19
@Input Using Unique with ShadowRoot components.
import { ShadowRoot, Unique } from 'retend';

const ShadowComponent = () => {
  return (
    <Unique name="shadow-unique">
      {() => (
        <ShadowRoot mode="open">
          {() => (
            <div>
              <style>
                {`div { color: blue; }`}
              </style>
              <div>Styled in Shadow DOM</div>
            </div>
          )}
        </ShadowRoot>
      )}
    </Unique>
  );
};
@Note ShadowRoot is preserved when Unique component moves.

---

@Example 20
@Input Unique component in routing setup.
import { Cell, Router, Route, Link, Unique } from 'retend';

const PersistentSidebar = () => {
  return (
    <Unique name="sidebar">
      {() => (
        <aside style={{ width: '200px', background: '#f0f0f0' }}>
          <h3>Sidebar</h3>
          <p>Always visible</p>
        </aside>
      )}
    </Unique>
  );
};

const routes = Route.create({
  '/': () => (
    <div>
      <PersistentSidebar />
      <main>Home Content</main>
    </div>
  ),
  '/about': () => (
    <div>
      <PersistentSidebar />
      <main>About Content</main>
    </div>
  ),
});

const App = () => {
  return <Router routes={routes} />;
};
@Note Sidebar persists across route changes.

---

@Example 21
@Input Saving and restoring canvas state.
import { Unique } from 'retend';

const DrawingCanvas = () => {
  return (
    <Unique
      name="canvas"
      onSave={(el) => {
        const canvas = el.querySelector('canvas');
        return {
          dataURL: canvas?.toDataURL() || '',
        };
      }}
      onRestore={(el, data) => {
        if (data?.dataURL) {
          const canvas = el.querySelector('canvas');
          const ctx = canvas?.getContext('2d');
          const img = new Image();
          img.onload = () => {
            ctx?.drawImage(img, 0, 0);
          };
          img.src = data.dataURL;
        }
      }}
    >
      {() => <canvas width="400" height="300" />}
    </Unique>
  );
};
@Note Canvas drawing is preserved across moves.

---

@Example 22
@Input Multiple Unique instances moving independently.
import { Cell, If, Unique } from 'retend';

const App = () => {
  const showFirstInA = Cell.source(true);
  const showSecondInA = Cell.source(false);
  return (
    <div>
      <div style={{ border: '1px solid red' }}>
        Container A:
        {If(showFirstInA, () => (
          <Unique name="first">
            {() => <div>First Unique</div>}
          </Unique>
        ))}
        {If(showSecondInA, () => (
          <Unique name="second">
            {() => <div>Second Unique</div>}
          </Unique>
        ))}
      </div>
      <div style={{ border: '1px solid blue' }}>
        Container B:
        {If(!showFirstInA, () => (
          <Unique name="first">
            {() => <div>First Unique</div>}
          </Unique>
        ))}
        {If(!showSecondInA, () => (
          <Unique name="second">
            {() => <div>Second Unique</div>}
          </Unique>
        ))}
      </div>
    </div>
  );
};
@Note Each unique name moves independently.

---

@Example 23
@Input Unique component with iframe that preserves state.
import { Unique } from 'retend';

const EmbeddedContent = () => {
  return (
    <Unique name="embedded-iframe">
      {() => (
        <iframe
          src="https://example.com"
          width="600"
          height="400"
          style={{ border: '1px solid gray' }}
        />
      )}
    </Unique>
  );
};
@Note iframe navigation state persists across component moves.

---

@Example 24
@Input Unique with dynamic content based on props.
import { Cell, Switch, Unique } from 'retend';

const VideoPlayer = ({ videoId }) => {
  return (
    <Unique name={`video-${videoId}`}>
      {() => (
        <video src={`https://example.com/video-${videoId}.mp4`} controls>
          Your browser does not support the video tag.
        </video>
      )}
    </Unique>
  );
};

const App = () => {
  const currentVideo = Cell.source('intro');
  return (
    <div>
      {Switch(currentVideo, {
        intro: () => <VideoPlayer videoId="intro" />,
        tutorial: () => <VideoPlayer videoId="tutorial" />,
      })}
    </div>
  );
};
@Note Different video IDs create separate unique instances.

---

@Example 25
@Input Preserving Web Component state.
import { Unique } from 'retend';

const WebComponentWrapper = () => {
  return (
    <Unique name="web-component">
      {() => <custom-element data-value="preserved" />}
    </Unique>
  );
};
@Note Custom elements maintain their internal state.
