@Title createUnique
@Description The `createUnique` factory function creates components that preserve their identity and internal state across different locations in your application. DOM nodes are moved instead of recreated, maintaining state like video playback, scroll position, or form input values.

---

@Example 1
@Input Basic unique component creation.
import { createUnique } from 'retend';

const UniqueContent = createUnique(() => {
  return <div>This content is unique!</div>;
});

const App = () => {
  return (
    <div>
      <UniqueContent />
    </div>
  );
};
@Note The factory function returns a component that can be used like any other component.
@Note By default, the component's identity is tied to the render function itself.

---

@Example 2
@Input Using the id prop to distinguish multiple instances.
import { createUnique } from 'retend';

const UniquePanel = createUnique(() => {
  return <div>Panel content</div>;
});

const App = () => {
  return (
    <div>
      <UniquePanel id="left-panel" />
      <UniquePanel id="right-panel" />
    </div>
  );
};
@Note Each unique `id` creates a separate persistent instance.
@Note Without an `id`, all usages share the same instance.

---

@Example 3
@Input Video player that persists across navigation.
import { Cell, Switch, createUnique } from 'retend';

const VideoPlayer = createUnique(() => {
  return (
    <video src="https://example.com/video.mp4" controls autoplay>
      Your browser does not support the video tag.
    </video>
  );
});

const HomePage = () => {
  return (
    <div>
      <h1>Home</h1>
      <VideoPlayer />
    </div>
  );
};

const AboutPage = () => {
  return (
    <div>
      <h1>About</h1>
      <VideoPlayer />
    </div>
  );
};

const App = () => {
  const page = Cell.source('home');
  return (
    <div>
      {Switch(page, {
        home: HomePage,
        about: AboutPage,
      })}
    </div>
  );
};
@Note Video continues playing when switching pages.
@Note DOM element is moved, not recreated.

---

@Example 4
@Input Moving unique component with If conditional.
import { Cell, If, createUnique } from 'retend';

const MovableContent = createUnique(() => {
  return <div>I move around!</div>;
});

const App = () => {
  const showInFirst = Cell.source(true);
  const showInSecond = Cell.derived(() => !showInFirst.get());
  const toggle = () => {
    showInFirst.set(!showInFirst.get());
  };
  return (
    <div>
      <div>First: {If(showInFirst, () => <MovableContent />)}</div>
      <div>Second: {If(showInSecond, () => <MovableContent />)}</div>
      <button type="button" onClick={toggle}>Toggle Position</button>
    </div>
  );
};
@Note Component moves between positions without recreating.
@Note Use derived cells for proper reactivity when negating conditions.

---

@Example 5
@Input Unique with setup effects that persist.
import { Cell, Switch, createUnique, useSetupEffect } from 'retend';

const PersistentComponent = createUnique(() => {
  useSetupEffect(() => {
    console.log('Setup called once');
    return () => {
      console.log('Cleanup called when completely removed');
    };
  });
  return <div>Persistent content</div>;
});

const App = () => {
  const page = Cell.source('home');
  return (
    <div>
      {Switch(page, {
        home: () => (
          <div>
            Home: <PersistentComponent />
          </div>
        ),
        about: () => (
          <div>
            About: <PersistentComponent />
          </div>
        ),
      })}
    </div>
  );
};
@Note Setup effects run once and persist across location changes.

---

@Example 6
@Input Saving and restoring scroll position.
import { createUnique } from 'retend';

const ScrollableArea = createUnique(
  () => (
    <div style={{ height: '400px', overflow: 'auto' }}>
      <p>Content line 1</p>
      <p>Content line 2</p>
      <p>Content line 3</p>
    </div>
  ),
  {
    onSave: (el) => ({ scrollTop: el.scrollTop }),
    onRestore: (el, data) => {
      el.scrollTop = data.scrollTop;
    },
  }
);
@Note `onSave` captures custom state before moving.
@Note `onRestore` applies saved state at new location.

---

@Example 7
@Input Using the same component with different IDs for independent instances.
import { Cell, If, createUnique } from 'retend';

const VideoPlayer = createUnique(() => (
  <video src="video.mp4" controls />
));

const App = () => {
  const mainInHeader = Cell.source(true);
  const mainInBody = Cell.derived(() => !mainInHeader.get());
  const pipInHeader = Cell.source(false);
  const pipInBody = Cell.derived(() => !pipInHeader.get());
  
  const toggle = () => {
    mainInHeader.set(!mainInHeader.get());
    pipInHeader.set(!pipInHeader.get());
  };

  return (
    <div>
      <header>
        {If(mainInHeader, () => <VideoPlayer id="main" />)}
        {If(pipInHeader, () => <VideoPlayer id="pip" />)}
      </header>
      <main>
        {If(mainInBody, () => <VideoPlayer id="main" />)}
        {If(pipInBody, () => <VideoPlayer id="pip" />)}
      </main>
      <button type="button" onClick={toggle}>Swap Videos</button>
    </div>
  );
};
@Note Both videos use the same `VideoPlayer` component but have different IDs.
@Note Each ID creates a separate persistent instance that moves independently.
@Note Without an ID, all usages would share the same single instance.

---

@Example 8
@Input Accessing props reactively.
import { Cell, createUnique } from 'retend';

const Counter = createUnique((props) => {
  const label = Cell.derived(() => props.get().label || 'Count');
  const count = Cell.source(0);
  const increment = () => count.set(count.get() + 1);
  
  return (
    <div>
      <span>{label}: {count}</span>
      <button type="button" onClick={increment}>+1</button>
    </div>
  );
});

const App = () => {
  return (
    <div>
      <Counter label="Clicks" />
    </div>
  );
};
@Note Props are passed as a Cell, enabling reactive access to prop changes.
@Note Use `props.get()` to access current values, or derive cells for reactivity.

---

@Example 9
@Input Unique component with container styling.
import { createUnique } from 'retend';

const StyledUnique = createUnique(
  () => <div>Styled unique content</div>,
  {
    container: {
      class: 'my-class',
      style: { padding: '20px', border: '1px solid blue' },
      'data-test': 'unique-element',
    },
  }
);

const App = () => {
  return (
    <div>
      <StyledUnique />
    </div>
  );
};
@Note Container options are applied to the wrapper element.

---

@Example 10
@Input Audio player persisting across routes.
import { Cell, Switch, createUnique } from 'retend';

const AudioPlayer = createUnique(() => (
  <audio src="https://example.com/audio.mp3" controls autoplay>
    Your browser does not support the audio tag.
  </audio>
));

const App = () => {
  const route = Cell.source('home');
  return (
    <div>
      {Switch(route, {
        home: () => (
          <div>
            Home <AudioPlayer />
          </div>
        ),
        contact: () => (
          <div>
            Contact <AudioPlayer />
          </div>
        ),
      })}
    </div>
  );
};
@Note Audio continues playing when navigating between routes.

---

@Example 11
@Input Unique in a For loop with dynamic IDs.
import { Cell, For, createUnique } from 'retend';

const ItemComponent = createUnique((props) => {
  const name = Cell.derived(() => props.get().name);
  return <div>{name}</div>;
});

const App = () => {
  const items = Cell.source([
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
  ]);
  return (
    <div>
      {For(items, (item) => (
        <ItemComponent id={`item-${item.id}`} name={item.name} />
      ))}
    </div>
  );
};
@Note Use unique IDs per item to preserve each independently.

---

@Example 12
@Input Saving form input state.
import { createUnique } from 'retend';

const FormInput = createUnique(
  () => <input type="text" placeholder="Enter text..." />,
  {
    onSave: (el) => {
      const input = el.querySelector('input');
      return { value: input?.value || '' };
    },
    onRestore: (el, data) => {
      const input = el.querySelector('input');
      if (input && data) {
        input.value = data.value;
      }
    },
  }
);
@Note Input value is preserved when component moves.

---

@Example 13
@Input Unique component with nested reactive state.
import { Cell, createUnique, useSetupEffect } from 'retend';

const TimerComponent = createUnique(() => {
  const count = Cell.source(0);
  useSetupEffect(() => {
    const interval = setInterval(() => {
      count.set(count.get() + 1);
    }, 1000);
    return () => clearInterval(interval);
  });
  return <div>Count: {count}</div>;
});

const App = () => {
  return <TimerComponent />;
};
@Note Nested components maintain their state and effects.

---

@Example 14
@Input Conditionally rendering unique across different containers.
import { Cell, createUnique } from 'retend';

const SharedContent = createUnique(() => (
  <div>Shared across containers</div>
));

const App = () => {
  const location = Cell.source('left');
  const moveRight = () => location.set('right');
  const moveLeft = () => location.set('left');
  
  const isLeft = Cell.derived(() => location.get() === 'left');
  const isRight = Cell.derived(() => location.get() === 'right');
  
  return (
    <div style={{ display: 'flex', gap: '20px' }}>
      <div style={{ border: '1px solid red', padding: '10px' }}>
        Left: {If(isLeft, () => <SharedContent />)}
      </div>
      <div style={{ border: '1px solid blue', padding: '10px' }}>
        Right: {If(isRight, () => <SharedContent />)}
      </div>
      <button type="button" onClick={moveLeft}>Move Left</button>
      <button type="button" onClick={moveRight}>Move Right</button>
    </div>
  );
};

---

@Example 15
@Input Saving complex state with multiple data points.
import { createUnique } from 'retend';

const ComplexComponent = createUnique(
  () => (
    <div style={{ height: '300px', overflow: 'auto' }}>
      <p>Line 1</p>
      <p>Line 2</p>
    </div>
  ),
  {
    onSave: (el) => ({
      timestamp: Date.now(),
      scrollTop: el.scrollTop,
      customData: 'preserved',
    }),
    onRestore: (el, data) => {
      console.log('Restored at:', new Date(data.timestamp));
      el.scrollTop = data.scrollTop;
    },
  }
);
@Note onSave can return any custom data structure.

---

@Example 16
@Input Unique component with video and custom controls.
import { Cell, createUnique } from 'retend';

const VideoWithControls = createUnique(() => {
  const videoRef = Cell.source(null);
  const play = () => videoRef.get()?.play();
  const pause = () => videoRef.get()?.pause();
  
  return (
    <div>
      <video ref={videoRef} src="video.mp4">
        Your browser does not support the video tag.
      </video>
      <button type="button" onClick={play}>Play</button>
      <button type="button" onClick={pause}>Pause</button>
    </div>
  );
});
@Note Refs work inside unique components.

---

@Example 17
@Input Unique modal that persists across pages.
import { Cell, Switch, If, createUnique } from 'retend';

const Modal = createUnique(() => (
  <div style={{
    position: 'fixed',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    background: 'white',
    padding: '20px',
    boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
  }}>
    <h2>Modal Content</h2>
    <p>This modal persists across page changes</p>
  </div>
));

const App = () => {
  const showModal = Cell.source(false);
  const page = Cell.source('home');
  const toggleModal = () => showModal.set(!showModal.get());
  
  return (
    <div>
      {Switch(page, {
        home: () => <div>Home Page</div>,
        about: () => <div>About Page</div>,
      })}
      {If(showModal, () => <Modal />)}
      <button type="button" onClick={toggleModal}>Toggle Modal</button>
    </div>
  );
};

---

@Example 18
@Input Unique component that only cleans up when fully removed.
import { Cell, If, createUnique, useSetupEffect } from 'retend';

const ResourceComponent = createUnique(() => {
  useSetupEffect(() => {
    console.log('Resource initialized');
    const resource = { connected: true };
    return () => {
      console.log('Resource cleaned up');
      resource.connected = false;
    };
  });
  return <div>Resource Component</div>;
});

const App = () => {
  const show = Cell.source(true);
  const toggle = () => show.set(!show.get());
  
  return (
    <div>
      {If(show, () => <ResourceComponent />)}
      <button type="button" onClick={toggle}>Toggle</button>
    </div>
  );
};
@Note Cleanup only runs when all instances are removed.

---

@Example 19
@Input Using Unique with ShadowRoot components.
import { ShadowRoot, createUnique } from 'retend';

const ShadowComponent = createUnique(() => (
  <ShadowRoot mode="open">
    {() => (
      <div>
        <style>
          {`div { color: blue; }`}
        </style>
        <div>Styled in Shadow DOM</div>
      </div>
    )}
  </ShadowRoot>
));
@Note ShadowRoot is preserved when unique component moves.

---

@Example 20
@Input Unique component in routing setup.
import { Cell, Router, Route, Link, createUnique } from 'retend';

const PersistentSidebar = createUnique(() => (
  <aside style={{ width: '200px', background: '#f0f0f0' }}>
    <h3>Sidebar</h3>
    <p>Always visible</p>
  </aside>
));

const routes = Route.create({
  '/': () => (
    <div>
      <PersistentSidebar />
      <main>Home Content</main>
    </div>
  ),
  '/about': () => (
    <div>
      <PersistentSidebar />
      <main>About Content</main>
    </div>
  ),
});

const App = () => {
  return <Router routes={routes} />;
};
@Note Sidebar persists across route changes.

---

@Example 21
@Input Saving and restoring canvas state.
import { createUnique } from 'retend';

const DrawingCanvas = createUnique(
  () => <canvas width="400" height="300" />,
  {
    onSave: (el) => {
      const canvas = el.querySelector('canvas');
      return { dataURL: canvas?.toDataURL() || '' };
    },
    onRestore: (el, data) => {
      if (data?.dataURL) {
        const canvas = el.querySelector('canvas');
        const ctx = canvas?.getContext('2d');
        const img = new Image();
        img.onload = () => ctx?.drawImage(img, 0, 0);
        img.src = data.dataURL;
      }
    },
  }
);
@Note Canvas drawing is preserved across moves.

---

@Example 22
@Input Multiple unique instances moving independently.
import { Cell, If, createUnique } from 'retend';

const Panel = createUnique((props) => {
  const label = Cell.derived(() => props.get().label);
  return <div>{label} Unique</div>;
});

const App = () => {
  const showFirstInA = Cell.source(true);
  const showFirstInB = Cell.derived(() => !showFirstInA.get());
  const showSecondInA = Cell.source(false);
  const showSecondInB = Cell.derived(() => !showSecondInA.get());
  
  return (
    <div>
      <div style={{ border: '1px solid red' }}>
        Container A:
        {If(showFirstInA, () => <Panel id="first" label="First" />)}
        {If(showSecondInA, () => <Panel id="second" label="Second" />)}
      </div>
      <div style={{ border: '1px solid blue' }}>
        Container B:
        {If(showFirstInB, () => <Panel id="first" label="First" />)}
        {If(showSecondInB, () => <Panel id="second" label="Second" />)}
      </div>
    </div>
  );
};
@Note Each unique ID moves independently.

---

@Example 23
@Input Unique component with iframe that preserves state.
import { createUnique } from 'retend';

const EmbeddedContent = createUnique(() => (
  <iframe
    src="https://example.com"
    width="600"
    height="400"
    style={{ border: '1px solid gray' }}
  />
));
@Note iframe navigation state persists across component moves.

---

@Example 24
@Input Unique with dynamic content based on props.
import { Cell, Switch, createUnique } from 'retend';

const VideoPlayer = createUnique((props) => {
  const src = Cell.derived(() => {
    const videoId = props.get().videoId;
    return `https://example.com/video-${videoId}.mp4`;
  });
  
  return (
    <video src={src} controls>
      Your browser does not support the video tag.
    </video>
  );
});

const App = () => {
  const currentVideo = Cell.source('intro');
  return (
    <div>
      {Switch(currentVideo, {
        intro: () => <VideoPlayer id="intro" videoId="intro" />,
        tutorial: () => <VideoPlayer id="tutorial" videoId="tutorial" />,
      })}
    </div>
  );
};
@Note Different video IDs create separate unique instances.

---

@Example 25
@Input Preserving Web Component state.
import { createUnique } from 'retend';

const WebComponentWrapper = createUnique(() => (
  <custom-element data-value="preserved" />
));
@Note Custom elements maintain their internal state.

---

@Example 26
@Input Reactive container attributes.
import { Cell, createUnique } from 'retend';

const className = Cell.source('initial-class');

const DynamicContainer = createUnique(
  () => <div>Content</div>,
  {
    container: { class: className },
  }
);

const App = () => {
  const updateClass = () => className.set('updated-class');
  return (
    <div>
      <DynamicContainer />
      <button type="button" onClick={updateClass}>Update Class</button>
    </div>
  );
};
@Note Container attributes can be reactive Cells.

---

@Example 27
@Input Nested unique components.
import { createUnique, useSetupEffect } from 'retend';

const Inner = createUnique(() => {
  useSetupEffect(() => {
    console.log('Inner setup');
  });
  return <div>Inner Content</div>;
});

const Outer = createUnique(() => (
  <div class="outer-box">
    <Inner id="nested-inner" />
  </div>
));

const App = () => {
  return <Outer id="outer" />;
};
@Note Unique components can be nested within each other.
@Note Each maintains its own identity and lifecycle.
