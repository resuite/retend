diff --git a/docs/README.md b/docs/README.md
index 06a6bff..885ab34 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -2086,52 +2086,70 @@ Retend provides several advanced components that can help you build complex UIs.
 
 These components are specifically for web-based rendering and are documented in the [retend-web documentation](../packages/retend-web/README.md).
 
-### Unique
+### createUnique
 
-The `Unique` component ensures that only one instance of a component exists across your entire application, identified by its `name` prop. When multiple `Unique` components with the same name appear in different parts of your component tree, the DOM nodes are preserved and moved to the new location instead of being recreated. This is particularly useful for maintaining state in components like video players, audio elements, or any content where you want to preserve DOM state across different views.
+The `createUnique` factory function creates components that preserve their identity and internal state across different locations in your application. DOM nodes are moved instead of recreated, maintaining state like video playback, scroll position, or form input values.
 
 **Key Features:**
 
-- Only one instance per unique name exists at any time
+- Only one instance per unique identity exists at any time
 - DOM nodes are physically moved, not recreated
 - Setup effects run once and persist until all instances are unmounted
 - Optional state saving and restoration with `onSave` and `onRestore`
 - Works seamlessly with routing and conditional rendering
+- Props are passed reactively as a Cell
 
 - **Basic Usage**:
 
 ```jsx
-import { Unique } from 'retend';
+import { createUnique } from 'retend';
+
+const UniqueContent = createUnique(() => {
+  return <div>This content is unique!</div>;
+});
 
 function App() {
   return (
     <div>
-      <Unique name="my-unique-content">
-        {() => <div>This content is unique!</div>}
-      </Unique>
+      <UniqueContent />
     </div>
   );
 }
 ```
 
-The `children` prop must be a function that returns JSX. The `name` prop uniquely identifies this component instance.
+The factory function returns a component that can be used like any other component. By default, the component's identity is tied to the render function itself.
 
-- **Video Player Persisting Across Pages**:
+- **Using the id prop to distinguish instances**:
 
 ```jsx
-import { Cell, Switch, Unique } from 'retend';
+import { createUnique } from 'retend';
+
+const UniquePanel = createUnique(() => {
+  return <div>Panel content</div>;
+});
 
-function VideoPlayer() {
+function App() {
   return (
-    <Unique name="main-video">
-      {() => (
-        <video src="https://example.com/video.mp4" controls autoplay>
-          Your browser does not support the video tag.
-        </video>
-      )}
-    </Unique>
+    <div>
+      <UniquePanel id="left-panel" />
+      <UniquePanel id="right-panel" />
+    </div>
   );
 }
+```
+
+Each unique `id` creates a separate persistent instance. Without an `id`, all usages share the same instance.
+
+- **Video Player Persisting Across Pages**:
+
+```jsx
+import { Cell, Switch, createUnique } from 'retend';
+
+const VideoPlayer = createUnique(() => (
+  <video src="https://example.com/video.mp4" controls autoplay>
+    Your browser does not support the video tag.
+  </video>
+));
 
 function HomePage() {
   return (
@@ -2166,29 +2184,12 @@ function App() {
 
 In this example, the video continues playing when switching between pages because the same DOM element is moved rather than being destroyed and recreated.
 
-- **Multiple Instances with Same Name**:
-
-```jsx
-import { Unique } from 'retend';
-
-function App() {
-  return (
-    <div>
-      <Unique name="shared">{() => <p>First instance</p>}</Unique>
-      <Unique name="shared">{() => <p>Second instance</p>}</Unique>
-    </div>
-  );
-}
-```
-
-Only the second instance will render because the DOM node moves to the last location with that name.
-
 - **Setup Effects that Persist**:
 
 ```jsx
-import { Cell, Switch, Unique, useSetupEffect } from 'retend';
+import { Cell, Switch, createUnique, useSetupEffect } from 'retend';
 
-function PersistentComponent() {
+const PersistentComponent = createUnique(() => {
   useSetupEffect(() => {
     console.log('Setup called once');
     return () => {
@@ -2196,11 +2197,7 @@ function PersistentComponent() {
     };
   });
   return <div>Persistent content</div>;
-}
-
-function UniqueWrapper() {
-  return <Unique name="persistent">{() => <PersistentComponent />}</Unique>;
-}
+});
 
 function App() {
   const page = Cell.source('home');
@@ -2209,12 +2206,12 @@ function App() {
       {Switch(page, {
         home: () => (
           <div>
-            Home: <UniqueWrapper />
+            Home: <PersistentComponent />
           </div>
         ),
         about: () => (
           <div>
-            About: <UniqueWrapper />
+            About: <PersistentComponent />
           </div>
         ),
       })}
@@ -2228,82 +2225,86 @@ The setup effect runs once when the component is first created and the cleanup o
 - **Saving and Restoring State**:
 
 ```jsx
-import { Unique } from 'retend';
-
-function ScrollableArea() {
-  return (
-    <Unique
-      name="scroll-area"
-      onSave={(el) => ({ scrollTop: el.scrollTop })}
-      onRestore={(el, data) => {
-        el.scrollTop = data.scrollTop;
-      }}
-    >
-      {() => (
-        <div style={{ height: '400px', overflow: 'auto' }}>
-          <p>Content line 1</p>
-          <p>Content line 2</p>
-          <p>Content line 3</p>
-          {/* ... more content ... */}
-        </div>
-      )}
-    </Unique>
-  );
-}
+import { createUnique } from 'retend';
+
+const ScrollableArea = createUnique(
+  () => (
+    <div style={{ height: '400px', overflow: 'auto' }}>
+      <p>Content line 1</p>
+      <p>Content line 2</p>
+      <p>Content line 3</p>
+      {/* ... more content ... */}
+    </div>
+  ),
+  {
+    onSave: (el) => ({ scrollTop: el.scrollTop }),
+    onRestore: (el, data) => {
+      el.scrollTop = data.scrollTop;
+    },
+  }
+);
 ```
 
 The `onSave` callback is called when the component is about to move, allowing you to capture any state. The `onRestore` callback is called when the component arrives at its new location, allowing you to restore that state.
 
-- **Using with Refs**:
+- **Accessing Props Reactively**:
 
 ```jsx
-import { Cell, Unique } from 'retend';
+import { Cell, createUnique } from 'retend';
+
+const Counter = createUnique((props) => {
+  const label = Cell.derived(() => props.get().label || 'Count');
+  const count = Cell.source(0);
+  const increment = () => count.set(count.get() + 1);
 
-function App() {
-  const uniqueRef = Cell.source(null);
-  const logElement = () => {
-    console.log(uniqueRef.get());
-  };
   return (
     <div>
-      <Unique name="with-ref" ref={uniqueRef}>
-        {() => <div>Content with ref</div>}
-      </Unique>
-      <button type="button" onClick={logElement}>
-        Log Element
+      <span>
+        {label}: {count}
+      </span>
+      <button type="button" onClick={increment}>
+        +1
       </button>
     </div>
   );
-}
-```
-
-- **Custom Attributes**:
-
-```jsx
-import { Unique } from 'retend';
+});
 
 function App() {
   return (
     <div>
-      <Unique
-        name="styled-unique"
-        class="my-class"
-        style={{ padding: '20px', border: '1px solid blue' }}
-        data-test="unique-element"
-      >
-        {() => <div>Styled unique content</div>}
-      </Unique>
+      <Counter label="Clicks" />
     </div>
   );
 }
 ```
 
-Additional props are applied to the wrapper element (`retend-unique-instance` custom element).
+Props are passed as a Cell, enabling reactive access to prop changes. Use `props.get()` to access current values, or derive cells for reactivity.
 
-- **Dynamic Names in Lists**:
+- **Container Styling Options**:
 
 ```jsx
-import { Cell, For, Unique } from 'retend';
+import { createUnique } from 'retend';
+
+const StyledUnique = createUnique(() => <div>Styled unique content</div>, {
+  container: {
+    class: 'my-class',
+    style: { padding: '20px', border: '1px solid blue' },
+    'data-test': 'unique-element',
+  },
+});
+```
+
+Container options are applied to the wrapper element (`retend-unique-instance` custom element).
+
+- **Dynamic IDs in Lists**:
+
+```jsx
+import { Cell, For, createUnique } from 'retend';
+
+const ItemComponent = createUnique((props) => {
+  const name = Cell.derived(() => props.get().name);
+  return <div>{name}</div>;
+});
 
 function App() {
   const items = Cell.source([
@@ -2313,13 +2314,13 @@ function App() {
   return (
     <div>
       {For(items, (item) => (
-        <Unique name={`item-${item.id}`}>{() => <div>{item.name}</div>}</Unique>
+        <ItemComponent id={`item-${item.id}`} name={item.name} />
       ))}
     </div>
   );
 }
 ```
 
-Use unique names per item to preserve each independently when the list changes.
+Use unique IDs per item to preserve each independently when the list changes.
 
 These advanced components provide unique ways to manage DOM interactions, encapsulation, and component structures.
diff --git a/docs/syntax/20-unique.txt b/docs/syntax/20-unique.txt
index dc28cc7..25843ce 100644
--- a/docs/syntax/20-unique.txt
+++ b/docs/syntax/20-unique.txt
@@ -1,61 +1,60 @@
-@Title unique
-@Description The `Unique` component ensures only one instance of a component exists across your entire application by name. DOM nodes are preserved and moved instead of being recreated, maintaining state like video playback or scroll position.
+@Title createUnique
+@Description The `createUnique` factory function creates components that preserve their identity and internal state across different locations in your application. DOM nodes are moved instead of recreated, maintaining state like video playback, scroll position, or form input values.
 
 ---
 
 @Example 1
-@Input Basic Unique component with a name.
-import { Unique } from 'retend';
+@Input Basic unique component creation.
+import { createUnique } from 'retend';
+
+const UniqueContent = createUnique(() => {
+  return <div>This content is unique!</div>;
+});
 
 const App = () => {
   return (
     <div>
-      <Unique name="my-unique-content">
-        {() => <div>This content is unique!</div>}
-      </Unique>
+      <UniqueContent />
     </div>
   );
 };
-@Note The `name` prop uniquely identifies this component instance.
-@Note The `children` prop must be a function that returns JSX.
+@Note The factory function returns a component that can be used like any other component.
+@Note By default, the component's identity is tied to the render function itself.
 
 ---
 
 @Example 2
-@Input Multiple Unique components with the same name - only one renders.
-import { Unique } from 'retend';
+@Input Using the id prop to distinguish multiple instances.
+import { createUnique } from 'retend';
+
+const UniquePanel = createUnique(() => {
+  return <div>Panel content</div>;
+});
 
 const App = () => {
   return (
     <div>
-      <Unique name="shared">
-        {() => <p>First instance</p>}
-      </Unique>
-      <Unique name="shared">
-        {() => <p>Second instance</p>}
-      </Unique>
+      <UniquePanel id="left-panel" />
+      <UniquePanel id="right-panel" />
     </div>
   );
 };
-@Note Only the second instance renders; DOM moves to the last location.
+@Note Each unique `id` creates a separate persistent instance.
+@Note Without an `id`, all usages share the same instance.
 
 ---
 
 @Example 3
 @Input Video player that persists across navigation.
-import { Cell, Switch, Unique } from 'retend';
+import { Cell, Switch, createUnique } from 'retend';
 
-const VideoPlayer = () => {
+const VideoPlayer = createUnique(() => {
   return (
-    <Unique name="main-video">
-      {() => (
-        <video src="https://example.com/video.mp4" controls autoplay>
-          Your browser does not support the video tag.
-        </video>
-      )}
-    </Unique>
+    <video src="https://example.com/video.mp4" controls autoplay>
+      Your browser does not support the video tag.
+    </video>
   );
-};
+});
 
 const HomePage = () => {
   return (
@@ -92,39 +91,37 @@ const App = () => {
 ---
 
 @Example 4
-@Input Moving Unique component with If conditional.
-import { Cell, If, Unique } from 'retend';
+@Input Moving unique component with If conditional.
+import { Cell, If, createUnique } from 'retend';
 
-const UniqueContent = () => {
-  return (
-    <Unique name="movable-content">
-      {() => <div>I move around!</div>}
-    </Unique>
-  );
-};
+const MovableContent = createUnique(() => {
+  return <div>I move around!</div>;
+});
 
 const App = () => {
   const showInFirst = Cell.source(true);
+  const showInSecond = Cell.derived(() => !showInFirst.get());
   const toggle = () => {
     showInFirst.set(!showInFirst.get());
   };
   return (
     <div>
-      <div>First: {If(showInFirst, UniqueContent)}</div>
-      <div>Second: {If(!showInFirst, UniqueContent)}</div>
+      <div>First: {If(showInFirst, () => <MovableContent />)}</div>
+      <div>Second: {If(showInSecond, () => <MovableContent />)}</div>
       <button type="button" onClick={toggle}>Toggle Position</button>
     </div>
   );
 };
 @Note Component moves between positions without recreating.
+@Note Use derived cells for proper reactivity when negating conditions.
 
 ---
 
 @Example 5
 @Input Unique with setup effects that persist.
-import { Cell, Switch, Unique, useSetupEffect } from 'retend';
+import { Cell, Switch, createUnique, useSetupEffect } from 'retend';
 
-const PersistentComponent = () => {
+const PersistentComponent = createUnique(() => {
   useSetupEffect(() => {
     console.log('Setup called once');
     return () => {
@@ -132,15 +129,7 @@ const PersistentComponent = () => {
     };
   });
   return <div>Persistent content</div>;
-};
-
-const UniqueWrapper = () => {
-  return (
-    <Unique name="persistent">
-      {() => <PersistentComponent />}
-    </Unique>
-  );
-};
+});
 
 const App = () => {
   const page = Cell.source('home');
@@ -149,12 +138,12 @@ const App = () => {
       {Switch(page, {
         home: () => (
           <div>
-            Home: <UniqueWrapper />
+            Home: <PersistentComponent />
           </div>
         ),
         about: () => (
           <div>
-            About: <UniqueWrapper />
+            About: <PersistentComponent />
           </div>
         ),
       })}
@@ -167,114 +156,131 @@ const App = () => {
 
 @Example 6
 @Input Saving and restoring scroll position.
-import { Unique } from 'retend';
-
-const ScrollableArea = () => {
-  return (
-    <Unique
-      name="scroll-area"
-      onSave={(el) => ({ scrollTop: el.scrollTop })}
-      onRestore={(el, data) => {
-        el.scrollTop = data.scrollTop;
-      }}
-    >
-      {() => (
-        <div style={{ height: '400px', overflow: 'auto' }}>
-          <p>Content line 1</p>
-          <p>Content line 2</p>
-          <p>Content line 3</p>
-        </div>
-      )}
-    </Unique>
-  );
-};
+import { createUnique } from 'retend';
+
+const ScrollableArea = createUnique(
+  () => (
+    <div style={{ height: '400px', overflow: 'auto' }}>
+      <p>Content line 1</p>
+      <p>Content line 2</p>
+      <p>Content line 3</p>
+    </div>
+  ),
+  {
+    onSave: (el) => ({ scrollTop: el.scrollTop }),
+    onRestore: (el, data) => {
+      el.scrollTop = data.scrollTop;
+    },
+  }
+);
 @Note `onSave` captures custom state before moving.
 @Note `onRestore` applies saved state at new location.
 
 ---
 
 @Example 7
-@Input Multiple unique components with different names.
-import { Unique } from 'retend';
+@Input Using the same component with different IDs for independent instances.
+import { Cell, If, createUnique } from 'retend';
+
+const VideoPlayer = createUnique(() => (
+  <video src="video.mp4" controls />
+));
 
 const App = () => {
+  const mainInHeader = Cell.source(true);
+  const mainInBody = Cell.derived(() => !mainInHeader.get());
+  const pipInHeader = Cell.source(false);
+  const pipInBody = Cell.derived(() => !pipInHeader.get());
+  
+  const toggle = () => {
+    mainInHeader.set(!mainInHeader.get());
+    pipInHeader.set(!pipInHeader.get());
+  };
+
   return (
     <div>
-      <Unique name="header-video">
-        {() => <video src="header.mp4" controls />}
-      </Unique>
-      <Unique name="main-content">
-        {() => <div>Main content here</div>}
-      </Unique>
-      <Unique name="footer-widget">
-        {() => <div>Footer widget</div>}
-      </Unique>
+      <header>
+        {If(mainInHeader, () => <VideoPlayer id="main" />)}
+        {If(pipInHeader, () => <VideoPlayer id="pip" />)}
+      </header>
+      <main>
+        {If(mainInBody, () => <VideoPlayer id="main" />)}
+        {If(pipInBody, () => <VideoPlayer id="pip" />)}
+      </main>
+      <button type="button" onClick={toggle}>Swap Videos</button>
     </div>
   );
 };
-@Note Each unique name creates a separate persistent instance.
+@Note Both videos use the same `VideoPlayer` component but have different IDs.
+@Note Each ID creates a separate persistent instance that moves independently.
+@Note Without an ID, all usages would share the same single instance.
 
 ---
 
 @Example 8
-@Input Using ref to access the Unique element.
-import { Cell, Unique } from 'retend';
+@Input Accessing props reactively.
+import { Cell, createUnique } from 'retend';
+
+const Counter = createUnique((props) => {
+  const label = Cell.derived(() => props.get().label || 'Count');
+  const count = Cell.source(0);
+  const increment = () => count.set(count.get() + 1);
+  
+  return (
+    <div>
+      <span>{label}: {count}</span>
+      <button type="button" onClick={increment}>+1</button>
+    </div>
+  );
+});
 
 const App = () => {
-  const uniqueRef = Cell.source(null);
-  const logElement = () => {
-    console.log(uniqueRef.get());
-  };
   return (
     <div>
-      <Unique name="with-ref" ref={uniqueRef}>
-        {() => <div>Content with ref</div>}
-      </Unique>
-      <button type="button" onClick={logElement}>Log Element</button>
+      <Counter label="Clicks" />
     </div>
   );
 };
-@Note `ref` provides access to the underlying DOM element.
+@Note Props are passed as a Cell, enabling reactive access to prop changes.
+@Note Use `props.get()` to access current values, or derive cells for reactivity.
 
 ---
 
 @Example 9
-@Input Unique component with custom attributes.
-import { Unique } from 'retend';
+@Input Unique component with container styling.
+import { createUnique } from 'retend';
+
+const StyledUnique = createUnique(
+  () => <div>Styled unique content</div>,
+  {
+    container: {
+      class: 'my-class',
+      style: { padding: '20px', border: '1px solid blue' },
+      'data-test': 'unique-element',
+    },
+  }
+);
 
 const App = () => {
   return (
     <div>
-      <Unique
-        name="styled-unique"
-        class="my-class"
-        style={{ padding: '20px', border: '1px solid blue' }}
-        data-test="unique-element"
-      >
-        {() => <div>Styled unique content</div>}
-      </Unique>
+      <StyledUnique />
     </div>
   );
 };
-@Note Additional props are applied to the wrapper element.
+@Note Container options are applied to the wrapper element.
 
 ---
 
 @Example 10
 @Input Audio player persisting across routes.
-import { Cell, Switch, Unique } from 'retend';
+import { Cell, Switch, createUnique } from 'retend';
 
-const AudioPlayer = () => {
-  return (
-    <Unique name="audio-player">
-      {() => (
-        <audio src="https://example.com/audio.mp3" controls autoplay>
-          Your browser does not support the audio tag.
-        </audio>
-      )}
-    </Unique>
-  );
-};
+const AudioPlayer = createUnique(() => (
+  <audio src="https://example.com/audio.mp3" controls autoplay>
+    Your browser does not support the audio tag.
+  </audio>
+));
 
 const App = () => {
   const route = Cell.source('home');
@@ -300,8 +306,13 @@ const App = () => {
 ---
 
 @Example 11
-@Input Unique in a For loop with dynamic names.
-import { Cell, For, Unique } from 'retend';
+@Input Unique in a For loop with dynamic IDs.
+import { Cell, For, createUnique } from 'retend';
+
+const ItemComponent = createUnique((props) => {
+  const name = Cell.derived(() => props.get().name);
+  return <div>{name}</div>;
+});
 
 const App = () => {
   const items = Cell.source([
@@ -311,49 +322,43 @@ const App = () => {
   return (
     <div>
       {For(items, (item) => (
-        <Unique name={`item-${item.id}`}>
-          {() => <div>{item.name}</div>}
-        </Unique>
+        <ItemComponent id={`item-${item.id}`} name={item.name} />
       ))}
     </div>
   );
 };
-@Note Use unique names per item to preserve each independently.
+@Note Use unique IDs per item to preserve each independently.
 
 ---
 
 @Example 12
 @Input Saving form input state.
-import { Unique } from 'retend';
-
-const FormInput = () => {
-  return (
-    <Unique
-      name="form-input"
-      onSave={(el) => {
-        const input = el.querySelector('input');
-        return { value: input?.value || '' };
-      }}
-      onRestore={(el, data) => {
-        const input = el.querySelector('input');
-        if (input && data) {
-          input.value = data.value;
-        }
-      }}
-    >
-      {() => <input type="text" placeholder="Enter text..." />}
-    </Unique>
-  );
-};
+import { createUnique } from 'retend';
+
+const FormInput = createUnique(
+  () => <input type="text" placeholder="Enter text..." />,
+  {
+    onSave: (el) => {
+      const input = el.querySelector('input');
+      return { value: input?.value || '' };
+    },
+    onRestore: (el, data) => {
+      const input = el.querySelector('input');
+      if (input && data) {
+        input.value = data.value;
+      }
+    },
+  }
+);
 @Note Input value is preserved when component moves.
 
 ---
 
 @Example 13
-@Input Unique component with nested components.
-import { Cell, Unique, useSetupEffect } from 'retend';
+@Input Unique component with nested reactive state.
+import { Cell, createUnique, useSetupEffect } from 'retend';
 
-const NestedComponent = () => {
+const TimerComponent = createUnique(() => {
   const count = Cell.source(0);
   useSetupEffect(() => {
     const interval = setInterval(() => {
@@ -362,46 +367,38 @@ const NestedComponent = () => {
     return () => clearInterval(interval);
   });
   return <div>Count: {count}</div>;
-};
+});
 
 const App = () => {
-  return (
-    <Unique name="nested-unique">
-      {() => <NestedComponent />}
-    </Unique>
-  );
+  return <TimerComponent />;
 };
 @Note Nested components maintain their state and effects.
 
 ---
 
 @Example 14
-@Input Conditionally rendering Unique across different containers.
-import { Cell, If, Unique } from 'retend';
+@Input Conditionally rendering unique across different containers.
+import { Cell, createUnique } from 'retend';
 
-const SharedContent = () => {
-  return (
-    <Unique name="shared-content">
-      {() => <div>Shared across containers</div>}
-    </Unique>
-  );
-};
+const SharedContent = createUnique(() => (
+  <div>Shared across containers</div>
+));
 
 const App = () => {
   const location = Cell.source('left');
-  const moveRight = () => {
-    location.set('right');
-  };
-  const moveLeft = () => {
-    location.set('left');
-  };
+  const moveRight = () => location.set('right');
+  const moveLeft = () => location.set('left');
+  
+  const isLeft = Cell.derived(() => location.get() === 'left');
+  const isRight = Cell.derived(() => location.get() === 'right');
+  
   return (
     <div style={{ display: 'flex', gap: '20px' }}>
       <div style={{ border: '1px solid red', padding: '10px' }}>
-        Left: {If(location, (loc) => If(loc === 'left', SharedContent))}
+        Left: {If(isLeft, () => <SharedContent />)}
       </div>
       <div style={{ border: '1px solid blue', padding: '10px' }}>
-        Right: {If(location, (loc) => If(loc === 'right', SharedContent))}
+        Right: {If(isRight, () => <SharedContent />)}
       </div>
       <button type="button" onClick={moveLeft}>Move Left</button>
       <button type="button" onClick={moveRight}>Move Right</button>
@@ -413,105 +410,85 @@ const App = () => {
 
 @Example 15
 @Input Saving complex state with multiple data points.
-import { Unique } from 'retend';
+import { createUnique } from 'retend';
 
-const ComplexComponent = () => {
-  return (
-    <Unique
-      name="complex"
-      onSave={(el) => {
-        return {
-          timestamp: Date.now(),
-          scrollTop: el.scrollTop,
-          customData: 'preserved',
-        };
-      }}
-      onRestore={(el, data) => {
-        console.log('Restored at:', new Date(data.timestamp));
-        el.scrollTop = data.scrollTop;
-      }}
-    >
-      {() => (
-        <div style={{ height: '300px', overflow: 'auto' }}>
-          <p>Line 1</p>
-          <p>Line 2</p>
-        </div>
-      )}
-    </Unique>
-  );
-};
+const ComplexComponent = createUnique(
+  () => (
+    <div style={{ height: '300px', overflow: 'auto' }}>
+      <p>Line 1</p>
+      <p>Line 2</p>
+    </div>
+  ),
+  {
+    onSave: (el) => ({
+      timestamp: Date.now(),
+      scrollTop: el.scrollTop,
+      customData: 'preserved',
+    }),
+    onRestore: (el, data) => {
+      console.log('Restored at:', new Date(data.timestamp));
+      el.scrollTop = data.scrollTop;
+    },
+  }
+);
 @Note onSave can return any custom data structure.
 
 ---
 
 @Example 16
 @Input Unique component with video and custom controls.
-import { Cell, Unique } from 'retend';
+import { Cell, createUnique } from 'retend';
 
-const VideoWithControls = () => {
+const VideoWithControls = createUnique(() => {
   const videoRef = Cell.source(null);
-  const play = () => {
-    videoRef.get()?.play();
-  };
-  const pause = () => {
-    videoRef.get()?.pause();
-  };
+  const play = () => videoRef.get()?.play();
+  const pause = () => videoRef.get()?.pause();
+  
   return (
-    <Unique name="video-controls">
-      {() => (
-        <div>
-          <video ref={videoRef} src="video.mp4">
-            Your browser does not support the video tag.
-          </video>
-          <button type="button" onClick={play}>Play</button>
-          <button type="button" onClick={pause}>Pause</button>
-        </div>
-      )}
-    </Unique>
+    <div>
+      <video ref={videoRef} src="video.mp4">
+        Your browser does not support the video tag.
+      </video>
+      <button type="button" onClick={play}>Play</button>
+      <button type="button" onClick={pause}>Pause</button>
+    </div>
   );
-};
-@Note Refs work inside Unique components.
+});
+@Note Refs work inside unique components.
 
 ---
 
 @Example 17
 @Input Unique modal that persists across pages.
-import { Cell, Switch, Unique, If } from 'retend';
-
-const Modal = () => {
-  return (
-    <Unique name="global-modal">
-      {() => (
-        <div style={{
-          position: 'fixed',
-          top: '50%',
-          left: '50%',
-          transform: 'translate(-50%, -50%)',
-          background: 'white',
-          padding: '20px',
-          boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
-        }}>
-          <h2>Modal Content</h2>
-          <p>This modal persists across page changes</p>
-        </div>
-      )}
-    </Unique>
-  );
-};
+import { Cell, Switch, If, createUnique } from 'retend';
+
+const Modal = createUnique(() => (
+  <div style={{
+    position: 'fixed',
+    top: '50%',
+    left: '50%',
+    transform: 'translate(-50%, -50%)',
+    background: 'white',
+    padding: '20px',
+    boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
+  }}>
+    <h2>Modal Content</h2>
+    <p>This modal persists across page changes</p>
+  </div>
+));
 
 const App = () => {
   const showModal = Cell.source(false);
   const page = Cell.source('home');
-  const toggleModal = () => {
-    showModal.set(!showModal.get());
-  };
+  const toggleModal = () => showModal.set(!showModal.get());
+  
   return (
     <div>
       {Switch(page, {
         home: () => <div>Home Page</div>,
         about: () => <div>About Page</div>,
       })}
-      {If(showModal, Modal)}
+      {If(showModal, () => <Modal />)}
       <button type="button" onClick={toggleModal}>Toggle Modal</button>
     </div>
   );
@@ -521,9 +498,9 @@ const App = () => {
 
 @Example 18
 @Input Unique component that only cleans up when fully removed.
-import { Cell, If, Unique, useSetupEffect } from 'retend';
+import { Cell, If, createUnique, useSetupEffect } from 'retend';
 
-const ResourceComponent = () => {
+const ResourceComponent = createUnique(() => {
   useSetupEffect(() => {
     console.log('Resource initialized');
     const resource = { connected: true };
@@ -533,24 +510,15 @@ const ResourceComponent = () => {
     };
   });
   return <div>Resource Component</div>;
-};
-
-const UniqueResource = () => {
-  return (
-    <Unique name="resource">
-      {() => <ResourceComponent />}
-    </Unique>
-  );
-};
+});
 
 const App = () => {
   const show = Cell.source(true);
-  const toggle = () => {
-    show.set(!show.get());
-  };
+  const toggle = () => show.set(!show.get());
+  
   return (
     <div>
-      {If(show, UniqueResource)}
+      {If(show, () => <ResourceComponent />)}
       <button type="button" onClick={toggle}>Toggle</button>
     </div>
   );
@@ -561,46 +529,34 @@ const App = () => {
 
 @Example 19
 @Input Using Unique with ShadowRoot components.
-import { ShadowRoot, Unique } from 'retend';
-
-const ShadowComponent = () => {
-  return (
-    <Unique name="shadow-unique">
-      {() => (
-        <ShadowRoot mode="open">
-          {() => (
-            <div>
-              <style>
-                {`div { color: blue; }`}
-              </style>
-              <div>Styled in Shadow DOM</div>
-            </div>
-          )}
-        </ShadowRoot>
-      )}
-    </Unique>
-  );
-};
-@Note ShadowRoot is preserved when Unique component moves.
+import { ShadowRoot, createUnique } from 'retend';
+
+const ShadowComponent = createUnique(() => (
+  <ShadowRoot mode="open">
+    {() => (
+      <div>
+        <style>
+          {`div { color: blue; }`}
+        </style>
+        <div>Styled in Shadow DOM</div>
+      </div>
+    )}
+  </ShadowRoot>
+));
+@Note ShadowRoot is preserved when unique component moves.
 
 ---
 
 @Example 20
 @Input Unique component in routing setup.
-import { Cell, Router, Route, Link, Unique } from 'retend';
+import { Cell, Router, Route, Link, createUnique } from 'retend';
 
-const PersistentSidebar = () => {
-  return (
-    <Unique name="sidebar">
-      {() => (
-        <aside style={{ width: '200px', background: '#f0f0f0' }}>
-          <h3>Sidebar</h3>
-          <p>Always visible</p>
-        </aside>
-      )}
-    </Unique>
-  );
-};
+const PersistentSidebar = createUnique(() => (
+  <aside style={{ width: '200px', background: '#f0f0f0' }}>
+    <h3>Sidebar</h3>
+    <p>Always visible</p>
+  </aside>
+));
 
 const routes = Route.create({
   '/': () => (
@@ -626,125 +582,104 @@ const App = () => {
 
 @Example 21
 @Input Saving and restoring canvas state.
-import { Unique } from 'retend';
-
-const DrawingCanvas = () => {
-  return (
-    <Unique
-      name="canvas"
-      onSave={(el) => {
+import { createUnique } from 'retend';
+
+const DrawingCanvas = createUnique(
+  () => <canvas width="400" height="300" />,
+  {
+    onSave: (el) => {
+      const canvas = el.querySelector('canvas');
+      return { dataURL: canvas?.toDataURL() || '' };
+    },
+    onRestore: (el, data) => {
+      if (data?.dataURL) {
         const canvas = el.querySelector('canvas');
-        return {
-          dataURL: canvas?.toDataURL() || '',
-        };
-      }}
-      onRestore={(el, data) => {
-        if (data?.dataURL) {
-          const canvas = el.querySelector('canvas');
-          const ctx = canvas?.getContext('2d');
-          const img = new Image();
-          img.onload = () => {
-            ctx?.drawImage(img, 0, 0);
-          };
-          img.src = data.dataURL;
-        }
-      }}
-    >
-      {() => <canvas width="400" height="300" />}
-    </Unique>
-  );
-};
+        const ctx = canvas?.getContext('2d');
+        const img = new Image();
+        img.onload = () => ctx?.drawImage(img, 0, 0);
+        img.src = data.dataURL;
+      }
+    },
+  }
+);
 @Note Canvas drawing is preserved across moves.
 
 ---
 
 @Example 22
-@Input Multiple Unique instances moving independently.
-import { Cell, If, Unique } from 'retend';
+@Input Multiple unique instances moving independently.
+import { Cell, If, createUnique } from 'retend';
+
+const Panel = createUnique((props) => {
+  const label = Cell.derived(() => props.get().label);
+  return <div>{label} Unique</div>;
+});
 
 const App = () => {
   const showFirstInA = Cell.source(true);
+  const showFirstInB = Cell.derived(() => !showFirstInA.get());
   const showSecondInA = Cell.source(false);
+  const showSecondInB = Cell.derived(() => !showSecondInA.get());
+  
   return (
     <div>
       <div style={{ border: '1px solid red' }}>
         Container A:
-        {If(showFirstInA, () => (
-          <Unique name="first">
-            {() => <div>First Unique</div>}
-          </Unique>
-        ))}
-        {If(showSecondInA, () => (
-          <Unique name="second">
-            {() => <div>Second Unique</div>}
-          </Unique>
-        ))}
+        {If(showFirstInA, () => <Panel id="first" label="First" />)}
+        {If(showSecondInA, () => <Panel id="second" label="Second" />)}
       </div>
       <div style={{ border: '1px solid blue' }}>
         Container B:
-        {If(!showFirstInA, () => (
-          <Unique name="first">
-            {() => <div>First Unique</div>}
-          </Unique>
-        ))}
-        {If(!showSecondInA, () => (
-          <Unique name="second">
-            {() => <div>Second Unique</div>}
-          </Unique>
-        ))}
+        {If(showFirstInB, () => <Panel id="first" label="First" />)}
+        {If(showSecondInB, () => <Panel id="second" label="Second" />)}
       </div>
     </div>
   );
 };
-@Note Each unique name moves independently.
+@Note Each unique ID moves independently.
 
 ---
 
 @Example 23
 @Input Unique component with iframe that preserves state.
-import { Unique } from 'retend';
-
-const EmbeddedContent = () => {
-  return (
-    <Unique name="embedded-iframe">
-      {() => (
-        <iframe
-          src="https://example.com"
-          width="600"
-          height="400"
-          style={{ border: '1px solid gray' }}
-        />
-      )}
-    </Unique>
-  );
-};
+import { createUnique } from 'retend';
+
+const EmbeddedContent = createUnique(() => (
+  <iframe
+    src="https://example.com"
+    width="600"
+    height="400"
+    style={{ border: '1px solid gray' }}
+  />
+));
 @Note iframe navigation state persists across component moves.
 
 ---
 
 @Example 24
 @Input Unique with dynamic content based on props.
-import { Cell, Switch, Unique } from 'retend';
+import { Cell, Switch, createUnique } from 'retend';
 
-const VideoPlayer = ({ videoId }) => {
+const VideoPlayer = createUnique((props) => {
+  const src = Cell.derived(() => {
+    const videoId = props.get().videoId;
+    return `https://example.com/video-${videoId}.mp4`;
+  });
+  
   return (
-    <Unique name={`video-${videoId}`}>
-      {() => (
-        <video src={`https://example.com/video-${videoId}.mp4`} controls>
-          Your browser does not support the video tag.
-        </video>
-      )}
-    </Unique>
+    <video src={src} controls>
+      Your browser does not support the video tag.
+    </video>
   );
-};
+});
 
 const App = () => {
   const currentVideo = Cell.source('intro');
   return (
     <div>
       {Switch(currentVideo, {
-        intro: () => <VideoPlayer videoId="intro" />,
-        tutorial: () => <VideoPlayer videoId="tutorial" />,
+        intro: () => <VideoPlayer id="intro" videoId="intro" />,
+        tutorial: () => <VideoPlayer id="tutorial" videoId="tutorial" />,
       })}
     </div>
   );
@@ -755,13 +690,60 @@ const App = () => {
 
 @Example 25
 @Input Preserving Web Component state.
-import { Unique } from 'retend';
+import { createUnique } from 'retend';
 
-const WebComponentWrapper = () => {
+const WebComponentWrapper = createUnique(() => (
+  <custom-element data-value="preserved" />
+));
+@Note Custom elements maintain their internal state.
+
+---
+
+@Example 26
+@Input Reactive container attributes.
+import { Cell, createUnique } from 'retend';
+
+const className = Cell.source('initial-class');
+
+const DynamicContainer = createUnique(
+  () => <div>Content</div>,
+  {
+    container: { class: className },
+  }
+);
+
+const App = () => {
+  const updateClass = () => className.set('updated-class');
   return (
-    <Unique name="web-component">
-      {() => <custom-element data-value="preserved" />}
-    </Unique>
+    <div>
+      <DynamicContainer />
+      <button type="button" onClick={updateClass}>Update Class</button>
+    </div>
   );
 };
-@Note Custom elements maintain their internal state.
+@Note Container attributes can be reactive Cells.
+
+---
+
+@Example 27
+@Input Nested unique components.
+import { createUnique, useSetupEffect } from 'retend';
+
+const Inner = createUnique(() => {
+  useSetupEffect(() => {
+    console.log('Inner setup');
+  });
+  return <div>Inner Content</div>;
+});
+
+const Outer = createUnique(() => (
+  <div class="outer-box">
+    <Inner id="nested-inner" />
+  </div>
+));
+
+const App = () => {
+  return <Outer id="outer" />;
+};
+@Note Unique components can be nested within each other.
+@Note Each maintains its own identity and lifecycle.
diff --git a/packages/retend-utils/README.md b/packages/retend-utils/README.md
index f137b01..f083571 100644
--- a/packages/retend-utils/README.md
+++ b/packages/retend-utils/README.md
@@ -20,7 +20,7 @@ This package provides a collection of utility hooks and components for [Retend](
   - [Components](#components)
     - [`Input`](#input)
     - [`FluidList`](#fluidlist)
-    - [`UniqueTransition`](#uniquetransition)
+    - [`createUniqueTransition`](#createuniquetransition)
 
 ## Installation
 
@@ -420,34 +420,98 @@ function MyComponent() {
 }
 ```
 
-### `UniqueTransition`
+### `createUniqueTransition`
 
-A wrapper around the `Unique` component that adds smooth [FLIP](https://aerotwist.com/blog/flip-your-animations/) animations when an element moves between different positions in the DOM tree.
+A factory function that creates unique components with smooth [FLIP](https://aerotwist.com/blog/flip-your-animations/) animations. When an element created with `createUniqueTransition` moves between different positions in the DOM tree, it automatically animates from its previous position and size to its new position and size using CSS transforms.
 
-When a `UniqueTransition` component with the same `name` unmounts and remounts elsewhere, it automatically animates from its previous position and size to its new position and size using CSS transforms.
+**Parameters:**
 
-**Props:**
+- `renderFn`: **Required**. A function that returns the JSX to be rendered. Receives props as a reactive Cell.
+- `options`: **Required**. An object with transition configuration:
+  - `transitionDuration`: The duration of the transition (e.g., `'300ms'`, `'0.5s'`).
+  - `transitionTimingFunction`: Optional. The easing function for the transition (e.g., `'ease-in-out'`). Default: `'ease'`.
+  - `maintainWidthDuringTransition`: Optional. If true, disables horizontal scaling during transitions.
+  - `maintainHeightDuringTransition`: Optional. If true, disables vertical scaling during transitions.
+  - `onSave`: Optional. A callback function `(element: HTMLElement) => CustomData` that runs just before the element moves. It can return custom data (e.g., scroll position) to be preserved.
+  - `onRestore`: Optional. A callback function `(element: HTMLElement, data: CustomData) => void` that runs after the element arrives at its new location. It receives the element and the data returned from `onSave`.
+  - `container`: Optional. Attributes to apply to the wrapper element.
+
+**Returns:**
 
-- `name`: **Required**. A unique string identifier for the element. The animation is triggered when an element with the same `name` is remounted elsewhere in the DOM.
-- `children`: **Required**. A function that returns the JSX to be rendered.
-- `transitionDuration`: Optional. The duration of the transition (e.g., `'300ms'`, `'0.5s'`).
-- `transitionTimingFunction`: Optional. The easing function for the transition (e.g., `'ease-in-out'`). Default: `'ease'`.
-- `onSave`: Optional. A callback function `(element: HTMLElement) => CustomData` that runs just before the element is unmounted. It can return custom data (e.g., scroll position) to be preserved.
-- `onRestore`: Optional. A callback function `(element: HTMLElement, data: CustomData) => void` that runs after the element is remounted. It receives the element and the data returned from `onSave`.
-- `...rest`: Other standard HTML attributes.
+- A unique component that can be used like any other component. Pass an `id` prop to distinguish multiple instances.
 
 **Example: Persistent Video Player**
 
 A video player that smoothly animates when moving between a sidebar and a main content area.
 
 ```tsx
-import { UniqueTransition } from 'retend-utils/components';
+import { createUniqueTransition } from 'retend-utils/components';
 
-function PersistentVideo({ src, name }) {
+const PersistentVideo = createUniqueTransition(
+  (props) => {
+    const src = Cell.derived(() => props.get().src);
+    return <VideoPlayer src={src} />;
+  },
+  { transitionDuration: '300ms' }
+);
+
+function App() {
   return (
-    <UniqueTransition name={name} transitionDuration="300ms">
-      {() => <VideoPlayer src={src} />}
-    </UniqueTransition>
+    <div>
+      <PersistentVideo id="main-video" src="/video.mp4" />
+    </div>
+  );
+}
+```
+
+**Example: Picture-in-Picture Transition**
+
+A video that animates between a main view and a picture-in-picture corner.
+
+```tsx
+import { Cell, If } from 'retend';
+import { createUniqueTransition } from 'retend-utils/components';
+
+const styles = {
+  main: { width: '640px', height: '360px' },
+  pip: {
+    position: 'fixed',
+    bottom: '20px',
+    right: '20px',
+    width: '200px',
+    height: '112px',
+  },
+};
+
+const VideoPlayer = createUniqueTransition(
+  () => <video src="video.mp4" controls />,
+  {
+    transitionDuration: '300ms',
+    transitionTimingFunction: 'cubic-bezier(0.4, 0, 0.2, 1)',
+  }
+);
+
+function App() {
+  const isPip = Cell.source(false);
+  const isMain = Cell.derived(() => !isPip.get());
+  const toggle = () => isPip.set(!isPip.get());
+
+  return (
+    <div>
+      {If(isMain, () => (
+        <div style={styles.main}>
+          <VideoPlayer />
+        </div>
+      ))}
+      {If(isPip, () => (
+        <div style={styles.pip}>
+          <VideoPlayer />
+        </div>
+      ))}
+      <button type="button" onClick={toggle}>
+        Toggle PiP
+      </button>
+    </div>
   );
 }
 ```
@@ -457,30 +521,45 @@ function PersistentVideo({ src, name }) {
 An item card that animates between a grid and a detail view while preserving its scroll position.
 
 ```tsx
-import { UniqueTransition } from 'retend-utils/components';
+import { Cell } from 'retend';
+import { createUniqueTransition } from 'retend-utils/components';
+
+const AnimatedCard = createUniqueTransition(
+  (props) => {
+    const title = Cell.derived(() => props.get().title);
+    return (
+      <div class="card">
+        <h3>{title}</h3>
+        <div class="content" style="overflow-y: auto; height: 100px;">
+          {/* ... long content ... */}
+        </div>
+      </div>
+    );
+  },
+  {
+    transitionDuration: '300ms',
+    onSave: (el) => ({ scrollTop: el.querySelector('.content')?.scrollTop }),
+    onRestore: (el, data) => {
+      if (data?.scrollTop) {
+        const contentEl = el.querySelector('.content');
+        if (contentEl) contentEl.scrollTop = data.scrollTop;
+      }
+    },
+  }
+);
+
+function ProductGrid() {
+  const items = Cell.source([
+    { id: 1, title: 'Product A' },
+    { id: 2, title: 'Product B' },
+  ]);
 
-function AnimatedCard({ item }) {
   return (
-    <UniqueTransition
-      name={`card-${item.id}`}
-      onSave={(el) => ({ scrollTop: el.querySelector('.content')?.scrollTop })}
-      onRestore={(el, data) => {
-        if (data?.scrollTop) {
-          const contentEl = el.querySelector('.content');
-          if (contentEl) contentEl.scrollTop = data.scrollTop;
-        }
-      }}
-      transitionDuration=".3s"
-    >
-      {() => (
-        <div class="card">
-          <h3>{item.title}</h3>
-          <div class="content" style="overflow-y: auto; height: 100px;">
-            {/* ... long content ... */}
-          </div>
-        </div>
-      )}
-    </UniqueTransition>
+    <div class="grid">
+      {For(items, (item) => (
+        <AnimatedCard id={`card-${item.id}`} title={item.title} />
+      ))}
+    </div>
   );
 }
 ```
diff --git a/packages/retend-utils/source/components/UniqueTransition.jsx b/packages/retend-utils/source/components/UniqueTransition.jsx
deleted file mode 100644
index f2f189b..0000000
--- a/packages/retend-utils/source/components/UniqueTransition.jsx
+++ /dev/null
@@ -1,288 +0,0 @@
-/** @import { JSX } from 'retend/jsx-runtime' */
-/** @import { UniqueProps } from 'retend'; */
-import { Cell } from 'retend';
-import { Unique } from 'retend';
-
-/**
- * @template CustomData
- * @typedef ElementUIState
- * @property {DOMRect} rect
- * @property {Animation[]} animations
- * @property {CustomData} [userData]
- */
-
-/**
- * @typedef TransitionProps
- * @property {string} [transitionDuration] How long the transition between states should take.
- * @property {string} [transitionTimingFunction] How the transition should be performed.
- * @property {boolean} [maintainWidthDuringTransition] If true, disables horizontal scaling during transitions.
- * @property {boolean} [maintainHeightDuringTransition] If true, disables vertical scaling during transitions.
- */
-
-/**
- * @template CustomData
- * @typedef {UniqueProps<CustomData> & TransitionProps} UniqueTransitionProps
- */
-
-/**
- * @param {DOMRect} from
- * @param {DOMRect} to
- * @param {object} [options]
- * @param {boolean} [options.maintainWidth]
- * @param {boolean} [options.maintainHeight]
- */
-function getInitialRelativeTransform(from, to, options = {}) {
-  const { maintainWidth = false, maintainHeight = false } = options;
-  const scaleX = maintainWidth ? 1 : from.width / to.width;
-  const scaleY = maintainHeight ? 1 : from.height / to.height;
-
-  const translateX = from.x - to.x;
-  const translateY = from.y - to.y;
-
-  return `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
-}
-
-const IS_DYNAMIC_CSS_EXPR = /(--)|(^calc\()/;
-
-/**
- *
- * @param {string | undefined} transitionDuration
- * @param {string | undefined} transitionTimingFunction
- * @param {HTMLElement} element
- */
-function parseTransitionOptions(
-  transitionDuration,
-  transitionTimingFunction,
-  element
-) {
-  let duration = 0;
-  let easing = transitionTimingFunction ?? 'ease';
-
-  if (!transitionDuration) {
-    return { duration, easing };
-  }
-
-  if (!transitionDuration.endsWith('s') || IS_DYNAMIC_CSS_EXPR.test(easing)) {
-    const durationVar = '--unique-transition-duration';
-    const easingVar = '--unique-transition-easing';
-
-    // Allows us to dynamically resolve the duration, so
-    // calc() or css vars can be passed in.
-    element.style.setProperty(durationVar, transitionDuration);
-    element.style.setProperty(easingVar, easing);
-
-    const styles = getComputedStyle(element);
-    const durationRaw = styles.getPropertyValue(durationVar);
-    duration = durationRaw.endsWith('ms')
-      ? Number(durationRaw.slice(0, -2))
-      : Number(durationRaw.slice(0, -1)) * 1000;
-
-    easing = styles.getPropertyValue(easingVar);
-  } else {
-    duration = transitionDuration.endsWith('ms')
-      ? Number(transitionDuration.slice(0, -2))
-      : Number(transitionDuration.slice(0, -1)) * 1000;
-  }
-
-  return { duration, easing };
-}
-
-/**
- * @template CustomData
- * @param {UniqueTransitionProps<CustomData>} props
- * @returns {UniqueProps<CustomData>}
- */
-const addTransitionProps = (props) => {
-  const {
-    onSave,
-    onRestore,
-    style: styleProp,
-    transitionDuration,
-    transitionTimingFunction,
-    maintainWidthDuringTransition,
-    maintainHeightDuringTransition,
-    ...rest
-  } = props;
-
-  /** @type {JSX.StyleValue} */
-  const style = { transformOrigin: 'top left' };
-
-  if (typeof styleProp === 'object' && !Cell.isCell(styleProp)) {
-    Object.assign(style, styleProp);
-  }
-
-  return {
-    ...rest,
-    style,
-    onSave(element) {
-      const userData = onSave?.(element);
-      const animations = element.getAnimations({ subtree: true });
-      for (const animation of animations) animation.pause();
-      const rect = element.getBoundingClientRect();
-      /** @type {ElementUIState<CustomData>} */
-      const elementState = { rect, animations, userData };
-      return /** @type {CustomData} */ (elementState);
-    },
-
-    onRestore(element, data) {
-      const {
-        rect: oldRect,
-        animations: pausedAnimations,
-        userData,
-      } = /** @type {ElementUIState<CustomData>} */ (data);
-
-      // @ts-expect-error: The type of user data is defined by user.
-      onRestore?.(element, userData);
-      if (oldRect.width === 0) return;
-      for (const animation of pausedAnimations) animation.play();
-
-      const options = parseTransitionOptions(
-        transitionDuration,
-        transitionTimingFunction,
-        element
-      );
-
-      // Animations on ancestors of the target may modify the positioning
-      // of the target element, making the bounding rect incorrect.
-      // We need to recompute the new rect after all parent animations
-      // have been scrubbed to the expected point on the document timeline.
-      const { duration } = options;
-      const parentAnimations = getAllParentAnimations(element);
-      for (const animation of parentAnimations) {
-        const currentTime = Number(animation.currentTime);
-        animation.currentTime = currentTime + duration;
-      }
-
-      requestAnimationFrame(() => {
-        const newRect = element.getBoundingClientRect();
-        for (const animation of parentAnimations) {
-          animation.currentTime = Number(animation.currentTime) - duration;
-        }
-        const parentTransform = getParentTransformMatrix(element);
-        const isInvertible =
-          Math.abs(
-            parentTransform.a * parentTransform.d -
-              parentTransform.b * parentTransform.c
-          ) > 1e-10;
-
-        const displacement = getInitialRelativeTransform(oldRect, newRect, {
-          maintainWidth: maintainWidthDuringTransition,
-          maintainHeight: maintainHeightDuringTransition,
-        });
-        const initialTransform = isInvertible
-          ? `${parentTransform.inverse().toString()} ${displacement}`
-          : displacement;
-        element.toggleAttribute('data-transitioning');
-        /** @type {ElementInternals} */ // @ts-expect-error: is a custom element
-        const internals = element.internals_;
-        internals?.states?.add('--transitioning');
-
-        element
-          .animate({ transform: [initialTransform, 'none'] }, options)
-          .finished.finally(() => {
-            element.removeAttribute('data-transitioning');
-            internals?.states?.delete('--transitioning');
-          });
-      });
-    },
-  };
-};
-
-/**
- * @param {Element} element
- */
-function getAllParentAnimations(element) {
-  const parentAnimations = [];
-
-  let parent = element.parentElement;
-  while (parent) {
-    const animations = parent
-      .getAnimations()
-      .filter((animation) => animation.timeline instanceof DocumentTimeline);
-    parentAnimations.push(...animations);
-    parent = parent.parentElement;
-  }
-
-  return parentAnimations;
-}
-
-/**
- * Get the cumulative transform matrix from all parent elements
- * @param {Element} element
- */
-function getParentTransformMatrix(element) {
-  let parent = element.parentElement;
-  let matrix = new DOMMatrix();
-
-  while (parent) {
-    const style = getComputedStyle(parent);
-    const transform = style.transform;
-    if (transform && transform !== 'none') {
-      const parentMatrix = new DOMMatrix(transform);
-      matrix = matrix.multiply(parentMatrix);
-    }
-    parent = parent.parentElement;
-  }
-
-  return matrix;
-}
-
-/**
- * A wrapper around the Unique component that adds smooth FLIP animations when the element
- * moves between different positions in the DOM tree.
- *
- * When a UniqueTransition component with the same `name` unmounts and remounts elsewhere,
- * it automatically animates from its previous position/size to its new position/size using
- * CSS transforms and transitions.
- *
- * @template CustomData
- * @param {UniqueTransitionProps<CustomData>} props
- * @returns {JSX.Template}
- *
- * @example
- * // Video player that smoothly animates when moving between sidebar and main view
- * function PersistentVideo({ src, name }) {
- *   return (
- *     <UniqueTransition name={name} transitionDuration="300ms">
- *       {() => <VideoPlayer src={src} />}
- *     </UniqueTransition>
- *   );
- * }
- *
- * @example
- * // Card that animates between grid and detail view while preserving scroll position
- * function AnimatedCard({ item }) {
- *   return (
- *     <UniqueTransition
- *       name={`card-${item.id}`}
- *       onSave={(el) => ({ scrollTop: el.scrollTop })}
- *       onRestore={(el, data) => { el.scrollTop = data.scrollTop; }}
- *       transitionDuration=".3s"
- *     >
- *       {() => (
- *         <div class="card">
- *           <h3>{item.title}</h3>
- *           <div class="content">{item.content}</div>
- *         </div>
- *       )}
- *     </UniqueTransition>
- *   );
- * }
- *
- * @example
- * // Modal that animates from trigger button position
- * function AnimatedModal({ isOpen, children }) {
- *   return isOpen && (
- *     <UniqueTransition name="modal">
- *       {() => (
- *         <div class="modal-overlay">
- *           <div class="modal-content">{children}</div>
- *         </div>
- *       )}
- *     </UniqueTransition>
- *   );
- * }
- */
-export function UniqueTransition(props) {
-  return <Unique {...addTransitionProps(props)} />;
-}
diff --git a/packages/retend-utils/source/components/index.ts b/packages/retend-utils/source/components/index.ts
index c6e7bdc..d167d94 100644
--- a/packages/retend-utils/source/components/index.ts
+++ b/packages/retend-utils/source/components/index.ts
@@ -1,4 +1,4 @@
 import 'retend-web/jsx-runtime';
 export * from './Input.js';
 export * from './FluidList.js';
-export * from './UniqueTransition.js'
+export * from './createUniqueTransition.js'
diff --git a/packages/retend/source/library/jsx.js b/packages/retend/source/library/jsx.js
index 5b4a727..fe4fd28 100644
--- a/packages/retend/source/library/jsx.js
+++ b/packages/retend/source/library/jsx.js
@@ -41,7 +41,7 @@ export function h(
       props instanceof ArgumentList
         ? props.data
         : typeof props === 'object'
-          ? [{ ...props }]
+          ? [props]
           : [];
 
     return renderer.handleComponent(tagOrFn, completeProps, fileData);
diff --git a/packages/retend/source/library/unique.js b/packages/retend/source/library/unique.js
index a8a6022..790fbf5 100644
--- a/packages/retend/source/library/unique.js
+++ b/packages/retend/source/library/unique.js
@@ -17,11 +17,12 @@ import { linkNodes } from '../library/utils.js';
 
 /**
  * @typedef UniqueStash
- * @property {Map<string, { data: any }>} instances
- * @property {Map<string, Cell<unknown | null>>} refs
- * @property {Map<string, ScopeSnapshot>} scopes
+ * @property {Map<string | Function, { data: any }>} instances
+ * @property {Map<string | Function, Cell<unknown | null>>} refs
+ * @property {Map<string | Function, ScopeSnapshot>} scopes
+ * @property {Map<string | Function, SourceCell<any>>} props
  * @property {Set<() => void>} pendingTeardowns
- * @property {Map<string, unknown[]>} stack
+ * @property {Map<string | Function, unknown[]>} stack
  * @property {() => void} onActivate
  */
 
@@ -29,44 +30,6 @@ import { linkNodes } from '../library/utils.js';
  * @typedef {WeakMap<Renderer<any>, UniqueStash>} RendererToUniqueStash
  */
 
-// /**
-//  * @typedef SavedElementInstance
-//  * @property {ChildNode[]} children
-//  * @property {ShadowRoot | null} shadowRoot
-//  * @property {any} [data]
-//  */
-
-/**
- * @template Data
- * @typedef UniqueSpecificProps
- * @property {string} name
- *   A unique identifier for this element. Elements with the same name across different
- *   parts of the component tree will be treated as the same logical element.
- *
- *   When a Unique component with this name unmounts and another with the same name mounts,
- *   the DOM nodes will be preserved and animated between positions.
- * @property {() => JSX.Template} children
- *   A function that returns the content to render. Must be a function to ensure proper
- *   re-evaluation when the component moves.
- *
- *   The JSX content to render inside the unique container
- * @property {Cell<HTMLElement | null>} [ref]
- *   Optional Cell reference to the underlying DOM element.
- *   If not provided, one will be created automatically.
- *
- * @property {(element: HTMLElement) => Data} [onSave]
- *   Called when the element is about to unmount, allowing you to save additional state.
- *
- * @property {(element: HTMLElement, data: Data) => void} [onRestore]
- *   Called when the element is being restored at a new location.
- */
-
-/**
- * Props for the Unique component.
- * @template CustomData
- * @typedef {JSX.BaseContainerProps & UniqueSpecificProps<CustomData>} UniqueProps
- */
-
 const UniqueComponentStash = Symbol('UniqueComponentStash');
 const elementName = 'retend-unique-instance';
 
@@ -89,6 +52,7 @@ const initUniqueStash = (renderer) => {
     scopes: new Map(),
     pendingTeardowns: new Set(),
     stack: new Map(),
+    props: new Map(),
     onActivate: checkForUniqueComponentTeardowns,
   };
   const rendererStash = new Map();
@@ -100,230 +64,293 @@ const initUniqueStash = (renderer) => {
 };
 
 /**
- * @template Data
- * @param {UniqueProps<Data>} props
- * @returns {JSX.Template}
+ * @template Data, Node
+ * @typedef {Object} UniqueComponentOptions
+ * @property {(node: Node) => Data} [onSave]
+ * @property {(node: Node, data: Data) => void} [onRestore]
+ * @property {JSX.BaseContainerProps} [container]
+ */
+
+/**
+ * @template {{}} Props
+ * @typedef {{ id?: string } & Props} UniqueProps
+ */
+
+/**
+ * @template {{}} Props
+ * @typedef {(props: UniqueProps<Props>) => JSX.Template} UniqueComponent
+ */
+
+/**
+ * @template {{}} Props
+ * @typedef {(props: Cell<UniqueProps<Props>>) => JSX.Template} UniqueComponentRenderFn
+ */
+
+/**
+ * Creates a component that preserves its identity and internal state
+ * even when its position in the render tree changes. Rather than being destroyed
+ * and recreated each time it renders, it persists one instance across different locations.
  *
- * Ensures only one instance of a component exists across your entire application,
- * identified by its `name`. Even if the same `name` appears in different parts of the tree,
- * it is only rendered once, and the DOM nodes are transferred to the final location
- * instead of being recreated. Setup effects within the component only run once when first created,
- * and continue until every instance of the component is unmounted.
+ * By default, the component's identity is tied to the render function itself. To distinguish
+ * between multiple shared instances of the same component, you can provide an explicit `id` prop.
  *
- * @example
- * function PersistentVideo({ src, name }) {
- *   return (
- *     <Unique name={name}>
- *       {() => <VideoPlayer src={src} />}
- *     </Unique>
- *   );
- * }
+ * Props remain fully reactive: any changes propagate through a Cell and automatically
+ * trigger re-evaluation of any derived values or effects inside the component.
+ *
+ * When a unique instance is removed from one place in the UI and later rendered elsewhere,
+ * it carries over its entire state intact, including:
+ * - All child nodes and their internal state
+ * - Any scoped reactive computations
+ * - Custom data managed via `onSave` / `onRestore` callbacks (if used)
+ *
+ * The component is only fully disposed once it is no longer rendered anywhere.
  *
- * function App() {
- *   const page = Cell.source('home');
+ * Common use cases include:
+ * - Media players that need to keep their playback position and state
+ *   during navigation or layout shifts
+ * - Form inputs that should retain their value, focus, and caret position
+ * - Expensive computations, WebSocket connections, or other heavy resources
+ *   that shouldn't be torn down unnecessarily
+ * - Stateful widgets that are moved between different containers or tabs
  *
+ * @example
+ * const UniqueCounter = createUnique((props) => {
+ *   const count = Cell.source(0);
+ *   const increment = () => count.set(count.get() + 1);
  *   return (
  *     <div>
- *       {Switch(page, {
- *         home: () => <HomePage><PersistentVideo name="main-video" src="intro.mp4" /></HomePage>,
- *         about: () => <AboutPage><PersistentVideo name="main-video" src="intro.mp4" /></AboutPage>
- *       })}
+ *       <button onClick={increment}>Count: {count}</button>
  *     </div>
  *   );
- * }
+ * });
+ *
+ * // Renders the same instance regardless of where it appears
+ * <UniqueCounter />
  *
  * @example
- * function PersistentScrollArea({ children, name }) {
- *   return (
- *     <Unique
- *       name={name}
- *       onSave={(el) => ({ scrollTop: el.scrollTop })}
- *       onRestore={(el, data) => { el.scrollTop = data.scrollTop; }}
- *     >
- *       {() => <div style="height: 400px; overflow: auto">{children}</div>}
- *     </Unique>
- *   );
- * }
+ * // With id - multiple instances distinguished by id prop
+ * const UniqueVideoPlayer = createUnique((props) => {
+ *   const src = Cell.derived(() => props.get().src);
+ *   return <video src={src} controls />;
+ * });
+ *
+ * // Each id creates a separate persistent instance
+ * <UniqueVideoPlayer id="main" src="/video1.mp4" />
+ * <UniqueVideoPlayer id="pip" src="/video2.mp4" />
  *
  * @example
- * function PersistentBookCard({ book }) {
- *   return (
- *     <Unique name={`book-${book.id}`}>
- *       {() => (
- *         <div class="book-card">
- *           <h3>{book.title}</h3>
- *           <VideoPlayer src={book.trailerUrl} />
- *         </div>
- *       )}
- *     </Unique>
- *   );
- * }
+ * // With custom state management
+ * const UniqueCanvas = createUnique(
+ *   (props) => {
+ *     const canvas = Cell.source(null);
+ *     useSetupEffect(() => {
+ *       const node = canvas.get();
+ *       if (!node) return;
+ *       // Initialize canvas context, listeners, etc.
+ *       const ctx = node.getContext('2d');
+ *       // ... setup
+ *     });
+ *     return <canvas ref={canvas} />;
+ *   },
+ *   {
+ *     onSave: (node) => {
+ *       // Extract custom state before component moves
+ *       return { customState: extractState(node) };
+ *     },
+ *     onRestore: (node, data) => {
+ *       // Restore custom state after component moves
+ *       applyState(node, data.customState);
+ *     }
+ *   }
+ * );
+ *
+ * @template {{}} Props - Props type (excluding id, which is added automatically)
+ * @template [Data=any] - Type of custom data managed by onSave/onRestore
+ * @template [Node=unknown] - Type of the root node (environment-specific)
  *
- * {For(books, (book) => <PersistentBookCard book={book} />)}
+ * @param {UniqueComponentRenderFn<Props>} renderFn
+ *   Function that receives reactive props as a Cell and returns a template.
+ *   Props updates propagate reactively through the Cell.
+ *
+ * @param {UniqueComponentOptions<Data, Node>} [options]
+ *
+ * @returns {UniqueComponent<Props>}
+ *   A component function that accepts props including an optional `id` string.
+ *   When `id` is omitted, a single instance is created per renderFn.
+ *   When `id` is provided, separate instances are created for each unique id.
  */
-export function Unique(props) {
-  const { globalData } = getGlobalContext();
-  const renderer = getActiveRenderer();
-  const hArgs = /** @type {const} */ ([
-    undefined,
-    undefined,
-    undefined,
-    undefined,
-    renderer,
-  ]);
-  const {
-    name,
-    children,
-    ref = Cell.source(null),
-    onSave,
-    onRestore,
-    ...rest
-  } = props;
+export function createUnique(renderFn, options = {}) {
+  /** @param {UniqueProps<Props>} props */
+  const Fn = (props) => {
+    const { id = renderFn } = props;
+    const { globalData } = getGlobalContext();
+    const renderer = getActiveRenderer();
+    const hArgs = /** @type {const} */ ([
+      undefined,
+      undefined,
+      undefined,
+      undefined,
+      renderer,
+    ]);
+    const { onSave, onRestore, container = {} } = options;
+    const ref = Cell.source(null);
 
-  /** @type {UniqueStash} */
-  const stash =
-    globalData.get(UniqueComponentStash)?.get(renderer) ??
-    initUniqueStash(renderer);
-  let journey = stash.stack.get(name);
-  if (!journey) {
-    journey = [];
-    stash.stack.set(name, journey);
-  }
-  const observer = useObserver();
+    /** @type {UniqueStash} */
+    const stash =
+      globalData.get(UniqueComponentStash)?.get(renderer) ??
+      initUniqueStash(renderer);
+    let journey = stash.stack.get(id);
+    if (!journey) {
+      journey = [];
+      stash.stack.set(id, journey);
+    }
+    let propSource = stash.props.get(id);
+    if (!propSource) {
+      propSource = Cell.source(props);
+      stash.props.set(id, propSource);
+    } else {
+      propSource.set(props);
+    }
+    const observer = useObserver();
 
-  const retendUniqueInstance = h(elementName, rest, ...hArgs);
-  let previous = stash.instances.get(name);
+    const retendUniqueInstance = h(elementName, container, ...hArgs);
+    let previous = stash.instances.get(id);
 
-  /** @param {unknown} div */
-  const saveState = (div) => {
-    renderer.setProperty(div, 'state', 'moved');
-    let customData;
-    // @ts-ignore: TODO: The base type should be unknown when more environments are added.
-    if (onSave && renderer.isActive(div)) customData = onSave(div);
+    /** @param {unknown} div */
+    const saveState = (div) => {
+      renderer.setProperty(div, 'state', 'moved');
+      let customData;
+      // @ts-ignore: TODO: The base type should be unknown when more environments are added.
+      if (onSave && renderer.isActive(div)) customData = onSave(div);
 
-    previous = renderer.saveContainerState(div, customData);
-    if (previous) stash.instances.set(name, previous);
-  };
+      previous = renderer.saveContainerState(div, customData);
+      if (previous) stash.instances.set(id, previous);
+    };
 
-  /** @param {unknown} div */
-  const restoreState = (div) => {
-    if (onRestore && previous) {
-      // @ts-ignore: TODO: The base type should be unknown when more environments are added.
-      onRestore(div, previous.data);
-    }
+    /** @param {unknown} div */
+    const restoreState = (div) => {
+      if (onRestore && previous?.data) {
+        // @ts-ignore: TODO: The base type should be unknown when more environments are added.
+        onRestore(div, previous.data);
+      }
 
-    stash.refs.set(name, Cell.source(div));
-    if (!journey.includes(div)) journey.push(div);
-    stash.instances.delete(name);
-  };
+      stash.refs.set(id, Cell.source(div));
+      if (!journey.includes(div)) journey.push(div);
+      stash.instances.delete(id);
+    };
 
-  if (!previous) {
-    const div = stash.refs.get(name)?.peek();
-    if (div) saveState(div);
-  }
-  let disposedByHMR = false;
+    if (!previous) {
+      const div = stash.refs.get(id)?.peek();
+      if (div) saveState(div);
+    }
+    let disposedByHMR = false;
 
-  // it's tricky to know when to dispose,
-  // because if this instance is removed, but then rendered somewhere else
-  // in the very next frame, we want both instances consolidated.
-  //
-  // Retend's lifecycle is:
-  // -> control flow component triggers change
-  // -> its current setup effects are disposed (we save state here)
-  // -> its dom nodes are removed
-  // -> its observer cleanups are called (we add event listener here)
-  // -> new component is rendered (we transfer nodes here)
-  // -> wait till next event loop (in activate fn)
-  // -> new setup effect is activated.
-  // -> retend:activate event dispatched.
-  // Once (7) runs, it means the next node should already be in the dom, and if
-  // it isn't, then we can dispose, because there is no continuity.
-  const teardown = () => {
-    const possibleNextInstance = journey.at(-1);
-    if (possibleNextInstance) {
+    // it's tricky to know when to dispose,
+    // because if this instance is removed, but then rendered somewhere else
+    // in the very next frame, we want both instances consolidated.
+    //
+    // Retend's lifecycle is:
+    // -> control flow component triggers change
+    // -> its current setup effects are disposed (we save state here)
+    // -> its dom nodes are removed
+    // -> its observer cleanups are called (we add event listener here)
+    // -> new component is rendered (we transfer nodes here)
+    // -> wait till next event loop (in activate fn)
+    // -> new setup effect is activated.
+    // -> retend:activate event dispatched.
+    // Once (7) runs, it means the next node should already be in the dom, and if
+    // it isn't, then we can dispose, because there is no continuity.
+    const teardown = () => {
+      const possibleNextInstance = journey.at(-1);
+      if (possibleNextInstance) {
+        stash.pendingTeardowns.delete(teardown);
+        return;
+      }
+      const scope = stash.scopes.get(id);
+      if (scope) {
+        scope.node.enable();
+        scope.node.dispose();
+      }
+      stash.instances.delete(id);
+      stash.refs.delete(id);
+      stash.scopes.delete(id);
+      stash.stack.delete(id);
       stash.pendingTeardowns.delete(teardown);
-      return;
-    }
-    const scope = stash.scopes.get(name);
-    if (scope) {
-      scope.node.enable();
-      scope.node.dispose();
-    }
-    stash.instances.delete(name);
-    stash.refs.delete(name);
-    stash.scopes.delete(name);
-    stash.stack.delete(name);
-    stash.pendingTeardowns.delete(teardown);
-  };
+    };
 
-  observer.onConnected(ref, (div) => {
-    restoreState(div);
-    const scope = stash.scopes.get(name);
-    if (scope) scope.node.enable();
+    observer.onConnected(ref, (div) => {
+      restoreState(div);
+      const scope = stash.scopes.get(id);
+      if (scope) scope.node.enable();
 
-    return () => {
-      const index = journey.indexOf(div);
-      if (index !== -1) journey.splice(index, 1);
-      const nextInstance = journey.at(-1);
-      if (!nextInstance && !disposedByHMR) stash.pendingTeardowns.add(teardown);
-    };
-  });
+      return () => {
+        const index = journey.indexOf(div);
+        if (index !== -1) journey.splice(index, 1);
+        const nextInstance = journey.at(-1);
+        if (!nextInstance && !disposedByHMR)
+          stash.pendingTeardowns.add(teardown);
+      };
+    });
 
-  useSetupEffect(() => {
-    const current = ref.peek();
+    useSetupEffect(() => {
+      const current = ref.peek();
 
-    return () => {
-      // We dont want to preserve the instance across HMR re-renders.
-      const hmrContext = __HMR_SYMBOLS.getHMRContext();
-      if (hmrContext?.current) {
-        const scope = stash.scopes.get(name);
-        if (scope) {
-          scope.node.enable();
-          scope.node.dispose();
+      return () => {
+        // We dont want to preserve the instance across HMR re-renders.
+        const hmrContext = __HMR_SYMBOLS.getHMRContext();
+        if (hmrContext?.current) {
+          const scope = stash.scopes.get(id);
+          if (scope) {
+            scope.node.enable();
+            scope.node.dispose();
+          }
+          stash.instances.delete(id);
+          stash.refs.delete(id);
+          stash.scopes.delete(id);
+          disposedByHMR = true;
+          return;
         }
-        stash.instances.delete(name);
-        stash.refs.delete(name);
-        stash.scopes.delete(name);
-        disposedByHMR = true;
-        return;
-      }
-      const scope = stash.scopes.get(name);
-      if (scope) scope.node.disable();
-      const currentElement = stash.refs.get(name)?.peek();
+        const scope = stash.scopes.get(id);
+        if (scope) scope.node.disable();
+        const currentElement = stash.refs.get(id)?.peek();
 
-      const index = journey.indexOf(currentElement);
-      if (index !== -1) journey.splice(index, 1);
+        const index = journey.indexOf(currentElement);
+        if (index !== -1) journey.splice(index, 1);
 
-      if (currentElement === current) {
-        saveState(/** @type {HTMLElement} */ (current));
+        if (currentElement === current) {
+          saveState(current);
 
-        const next = journey.at(-1);
-        if (next && currentElement !== next) {
-          renderer.append(next, Array.from(retendUniqueInstance.childNodes));
-          renderer.setProperty(next, 'state', 'restored');
-          restoreState(next);
+          const next = journey.at(-1);
+          if (next && currentElement !== next) {
+            renderer.append(next, Array.from(retendUniqueInstance.childNodes));
+            renderer.setProperty(next, 'state', 'restored');
+            restoreState(next);
+          }
         }
-      }
-    };
-  });
+      };
+    });
 
-  if (ref instanceof SourceCell) ref.set(retendUniqueInstance);
-  stash.refs.set(name, ref);
+    if (ref instanceof SourceCell) ref.set(retendUniqueInstance);
+    stash.refs.set(id, ref);
 
-  renderer.setProperty(retendUniqueInstance, 'name', name);
-  let childNodes;
-  if (previous) {
-    renderer.setProperty(retendUniqueInstance, 'state', 'restored');
-    renderer.restoreContainerState(retendUniqueInstance, previous);
-  } else {
-    renderer.setProperty(retendUniqueInstance, 'state', 'new');
-    childNodes = (() => {
-      const scopeSnapshot = createScopeSnapshot();
-      stash.scopes.set(name, scopeSnapshot);
-      return withScopeSnapshot(scopeSnapshot, () => h(children, {}, ...hArgs));
-    })();
-    linkNodes(retendUniqueInstance, childNodes, renderer);
-  }
+    let childNodes;
+    if (previous) {
+      renderer.setProperty(retendUniqueInstance, 'state', 'restored');
+      renderer.restoreContainerState(retendUniqueInstance, previous);
+    } else {
+      renderer.setProperty(retendUniqueInstance, 'state', 'new');
+      childNodes = (() => {
+        const scopeSnapshot = createScopeSnapshot();
+        stash.scopes.set(id, scopeSnapshot);
+        return withScopeSnapshot(scopeSnapshot, () =>
+          h(renderFn, propSource, ...hArgs)
+        );
+      })();
+      linkNodes(retendUniqueInstance, childNodes, renderer);
+    }
 
-  return retendUniqueInstance;
+    return retendUniqueInstance;
+  };
+  Object.defineProperty(Fn, 'name', { value: 'UniqueComponent' });
+  return Fn;
 }
diff --git a/tests/hydration.spec.tsx b/tests/hydration.spec.tsx
index 377e0d5..711dab1 100644
--- a/tests/hydration.spec.tsx
+++ b/tests/hydration.spec.tsx
@@ -4,7 +4,7 @@ import {
   If,
   type SourceCell,
   Switch,
-  Unique,
+  createUnique,
   getActiveRenderer,
   setActiveRenderer,
 } from 'retend';
@@ -247,19 +247,18 @@ describe('Hydration', () => {
 
   it('should hydrate Unique components', async () => {
     const count = Cell.source(0);
+    const Component = createUnique(() => (
+      <button
+        id="unique-btn"
+        type="button"
+        onClick={() => count.set(count.get() + 1)}
+      >
+        Unique: {count}
+      </button>
+    ));
     const template = () => (
       <div>
-        <Unique id="unique-comp" name="test-unique">
-          {() => (
-            <button
-              id="unique-btn"
-              type="button"
-              onClick={() => count.set(count.get() + 1)}
-            >
-              Unique: {count}
-            </button>
-          )}
-        </Unique>
+        <Component />
       </div>
     );
 
@@ -618,21 +617,20 @@ describe('Hydration', () => {
 
   it('should hydrate Teleport with Unique component inside', async () => {
     const count = Cell.source(0);
+    const Component = createUnique(() => (
+      <button
+        id="teleport-btn"
+        type="button"
+        onClick={() => count.set(count.get() + 1)}
+      >
+        Count: {count}
+      </button>
+    ));
     const template = () => (
       <div>
         <div id="unique-target" />
         <Teleport to="#unique-target">
-          <Unique id="teleported-unique" name="test">
-            {() => (
-              <button
-                id="teleport-btn"
-                type="button"
-                onClick={() => count.set(count.get() + 1)}
-              >
-                Count: {count}
-              </button>
-            )}
-          </Unique>
+          <Component />
         </Teleport>
       </div>
     );
@@ -906,19 +904,21 @@ describe('Hydration', () => {
 
   it('should hydrate Teleport with For containing Unique components', async () => {
     const items = Cell.source(['A', 'B', 'C']);
+    const Item = createUnique<{ item: string }>((props) => {
+      const { item } = props.get();
+      return (
+        <div class="unique-item" id={`item-el-${item}`}>
+          Item: {item}
+        </div>
+      );
+    });
     const template = () => (
       <div>
         <div id="unique-for-target" />
         <Teleport to="#unique-for-target">
           <div>
             {For(items, (item, index) => (
-              <Unique id={`item-${item}`} name={`unique-${index}`}>
-                {() => (
-                  <div class="unique-item" id={`item-el-${item}`}>
-                    Item: {item}
-                  </div>
-                )}
-              </Unique>
+              <Item id={`item-el-${index.get()}`} item={item} />
             ))}
           </div>
         </Teleport>
@@ -1282,20 +1282,22 @@ describe('Hydration', () => {
 
   it('should hydrate shadowroots with Unique component', async () => {
     const count = Cell.source(0);
+    const Component = createUnique(() => {
+      return (
+        <button
+          id="shadow-unique-btn"
+          type="button"
+          onClick={() => count.set(count.get() + 1)}
+        >
+          Unique: {count}
+        </button>
+      );
+    });
+
     const template = () => (
       <div id="unique-shadow-parent">
         <ShadowRoot>
-          <Unique id="shadow-unique" name="shadow-unique-test">
-            {() => (
-              <button
-                id="shadow-unique-btn"
-                type="button"
-                onClick={() => count.set(count.get() + 1)}
-              >
-                Unique: {count}
-              </button>
-            )}
-          </Unique>
+          <Component />
         </ShadowRoot>
       </div>
     );
diff --git a/tests/unique.spec.tsx b/tests/unique.spec.tsx
index 6332e91..2985220 100644
--- a/tests/unique.spec.tsx
+++ b/tests/unique.spec.tsx
@@ -6,7 +6,7 @@ import {
   runPendingSetupEffects,
   Switch,
   useSetupEffect,
-  Unique,
+  createUnique,
   getActiveRenderer,
 } from 'retend';
 import type { VNode } from 'retend-server/v-dom';
@@ -14,18 +14,18 @@ import type { DOMRenderer } from 'retend-web';
 import { ShadowRoot } from 'retend-web';
 
 const runTests = () => {
-  it('should render a <Unique/> component', async () => {
+  it('should render a Unique component', async () => {
     const renderer = getActiveRenderer() as DOMRenderer;
     const { host: window } = renderer;
     const uuid = crypto.randomUUID();
 
-    const UniqueContent = () => {
-      return <Unique name={uuid}>{() => <div>Unique Data</div>}</Unique>;
-    };
+    const UniqueContent = createUnique(() => {
+      return <div>Unique Data</div>;
+    });
 
     const doc = (
       <div>
-        Hello world: <UniqueContent />
+        Hello world: <UniqueContent id={uuid} />
       </div>
     );
 
@@ -37,19 +37,19 @@ const runTests = () => {
     body.replaceChildren();
   });
 
-  it('should only render one <Unique/> component', async () => {
+  it('should only render one Unique component', async () => {
     const renderer = getActiveRenderer() as DOMRenderer;
     const { host: window } = renderer;
     const uuid = crypto.randomUUID();
 
-    const UniqueContent = () => {
-      return <Unique name={uuid}>{() => <div>Unique Data</div>}</Unique>;
-    };
+    const UniqueContent = createUnique(() => {
+      return <div>Unique Data</div>;
+    });
 
     const doc = (
       <div>
-        Hello world: <UniqueContent />
-        Component 2?: <UniqueContent />
+        Hello world: <UniqueContent id={uuid} />
+        Component 2?: <UniqueContent id={uuid} />
       </div>
     );
 
@@ -66,25 +66,27 @@ describe('Unique', () => {
     browserSetup();
     runTests();
 
-    it('should move the <Unique/> component on change', async () => {
+    it('should move the Unique component on change', async () => {
       const renderer = getActiveRenderer() as DOMRenderer;
       const { host: window } = renderer;
       const uuid = crypto.randomUUID();
 
-      const UniqueContent = () => {
-        return <Unique name={uuid}>{() => <div>Unique Data</div>}</Unique>;
-      };
+      const UniqueContent = createUnique(() => {
+        return <div>Unique Data</div>;
+      });
 
       const { body } = window.document;
       const show = Cell.source(false);
       const element = (
         <div>
-          Showing content: {show}, <UniqueContent /> ||
-          {If(show, UniqueContent)}
+          Showing content: {show}, <UniqueContent id={uuid} /> ||
+          {If(show, () => (
+            <UniqueContent id={uuid} />
+          ))}
         </div>
-      );
+      ) as unknown as Node;
 
-      body.append(element as any);
+      body.append(element);
       await runPendingSetupEffects();
 
       expect(getTextContent(body)).toBe(
@@ -112,26 +114,26 @@ describe('Unique', () => {
       const setupFn = vi.fn();
       const cleanupFn = vi.fn();
 
-      const MainVideoPlayer = () => {
-        const MainContent = () => {
-          useSetupEffect(() => {
-            setupFn();
-            return cleanupFn;
-          });
+      const MainVideoPlayer = createUnique(() => {
+        useSetupEffect(() => {
+          setupFn();
+          return cleanupFn;
+        });
 
-          return (
-            <>
-              Playing video: <video src="https://example.com/video.mp4" />
-            </>
-          );
-        };
-        return <Unique name={uuid}>{() => <MainContent />}</Unique>;
-      };
+        return (
+          <>
+            Playing video:{' '}
+            <video src="https://example.com/video.mp4">
+              <track kind="captions" />
+            </video>
+          </>
+        );
+      });
 
       const ListView = () => {
         return (
           <>
-            List View: <MainVideoPlayer />
+            List View: <MainVideoPlayer id={uuid} />
           </>
         );
       };
@@ -139,7 +141,7 @@ describe('Unique', () => {
       const MainView = () => {
         return (
           <>
-            Main View: <MainVideoPlayer />
+            Main View: <MainVideoPlayer id={uuid} />
           </>
         );
       };
@@ -165,7 +167,7 @@ describe('Unique', () => {
       };
 
       const { body } = window.document;
-      body.append((<App />) as any);
+      body.append((<App />) as unknown as Element);
       await runPendingSetupEffects();
 
       expect(getTextContent(body)).toBe(
@@ -208,17 +210,13 @@ describe('Unique', () => {
       const setupFn = vi.fn();
       const cleanupFn = vi.fn();
 
-      const UniqueComponent = () => {
+      const UniqueComponent = createUnique(() => {
         useSetupEffect(() => {
           setupFn();
           return cleanupFn;
         });
         return <div>[Unique Component]</div>;
-      };
-
-      const UniqueComponentWrapper = () => {
-        return <Unique name={uuid}>{() => <UniqueComponent />}</Unique>;
-      };
+      });
 
       const showFirstComponentInstance = Cell.source(false);
       const showSecondComponentInstance = Cell.source(false);
@@ -227,15 +225,19 @@ describe('Unique', () => {
         return (
           <div>
             Unique Component Ctx:{' '}
-            {If(showFirstComponentInstance, UniqueComponentWrapper)} Unique
-            Component Ctx 2:{' '}
-            {If(showSecondComponentInstance, UniqueComponentWrapper)}
+            {If(showFirstComponentInstance, () => (
+              <UniqueComponent id={uuid} />
+            ))}{' '}
+            Unique Component Ctx 2:{' '}
+            {If(showSecondComponentInstance, () => (
+              <UniqueComponent id={uuid} />
+            ))}
           </div>
         );
       };
 
       const { body } = window.document;
-      body.append((<App />) as any);
+      body.append((<App />) as unknown as Node);
 
       expect(getTextContent(body)).toBe(
         'Unique Component Ctx:  Unique Component Ctx 2: '
@@ -301,26 +303,23 @@ describe('Unique', () => {
         restoreFn();
       };
 
-      const MusicPlayer = () => {
-        useSetupEffect(() => {
-          setupFn();
-        });
-
-        return (
-          <>
-            Music player:
-            <audio src="music.mp3" controls />
-          </>
-        );
-      };
+      const PersistentMusicPlayer = createUnique(
+        () => {
+          useSetupEffect(() => {
+            setupFn();
+          });
 
-      const PersistentMusicPlayer = () => {
-        return (
-          <Unique name={uuid} onSave={saveState} onRestore={restoreState}>
-            {() => <MusicPlayer />}
-          </Unique>
-        );
-      };
+          return (
+            <>
+              Music player:
+              <audio src="music.mp3" controls>
+                <track kind="captions" src="captions.vtt" />
+              </audio>
+            </>
+          );
+        },
+        { onSave: saveState, onRestore: restoreState }
+      );
 
       const page = Cell.source<'home' | 'about'>('home');
       const App = () => {
@@ -330,13 +329,13 @@ describe('Unique', () => {
               home: () => (
                 <div>
                   <h1>Home </h1>
-                  <PersistentMusicPlayer />
+                  <PersistentMusicPlayer id={uuid} />
                 </div>
               ),
               about: () => (
                 <div>
                   <h1>About </h1>
-                  <PersistentMusicPlayer />
+                  <PersistentMusicPlayer id={uuid} />
                 </div>
               ),
             })}
@@ -346,7 +345,7 @@ describe('Unique', () => {
 
       const { body } = window.document;
       const app = <App />;
-      body.append(app as any);
+      body.append(app as unknown as HTMLElement);
       await runPendingSetupEffects();
       expect(getTextContent(body)).toBe('Home Music player:');
       expect(setupFn).toHaveBeenCalledTimes(1);
@@ -364,17 +363,13 @@ describe('Unique', () => {
       const { host: window } = renderer;
       const page = Cell.source<'home' | 'about'>('home');
 
-      const PersistentMusicPlayer = () => {
+      const PersistentMusicPlayer = createUnique(() => {
         return (
-          <Unique name="music-playerr">
-            {() => (
-              <ShadowRoot>
-                <h2>Music player</h2>
-              </ShadowRoot>
-            )}
-          </Unique>
+          <ShadowRoot>
+            <h2>Music player</h2>
+          </ShadowRoot>
         );
-      };
+      });
 
       const App = () => {
         return (
@@ -383,13 +378,13 @@ describe('Unique', () => {
               home: () => (
                 <div>
                   <h1>Home </h1>
-                  <PersistentMusicPlayer />
+                  <PersistentMusicPlayer id="music-player" />
                 </div>
               ),
               about: () => (
                 <div>
                   <h1>About </h1>
-                  <PersistentMusicPlayer />
+                  <PersistentMusicPlayer id="music-player" />
                 </div>
               ),
             })}
@@ -399,7 +394,7 @@ describe('Unique', () => {
 
       const { body } = window.document;
       const app = <App />;
-      body.append(app as any);
+      body.append(app as unknown as Element);
       await runPendingSetupEffects();
       expect(getTextContent(body)).toBe('Home ');
       const unique = body.querySelector('retend-unique-instance');
@@ -418,13 +413,13 @@ describe('Unique', () => {
       const { host: window } = renderer;
       const uuid = crypto.randomUUID();
 
-      const UniqueContent = () => {
-        return <Unique name={uuid}>{() => <div>Unique Data</div>}</Unique>;
-      };
+      const UniqueContent = createUnique(() => {
+        return <div>Unique Data</div>;
+      });
 
       const doc = (
         <div>
-          Hello world: <UniqueContent />
+          Hello world: <UniqueContent id={uuid} />
         </div>
       );
 
@@ -442,30 +437,32 @@ describe('Unique', () => {
       const { host: window } = renderer;
       const uuid = crypto.randomUUID();
 
-      const UniqueContent = () => {
-        return <Unique name={uuid}>{() => <div>Unique Data</div>}</Unique>;
-      };
+      const UniqueContent = createUnique(() => {
+        return <div>Unique Data</div>;
+      });
 
       const { body } = window.document;
       const show = Cell.source(false);
       const element = (
         <div>
-          Showing content: {show}, <UniqueContent /> ||
-          {If(show, UniqueContent)}
+          Showing content: {show}, <UniqueContent id={uuid} /> ||
+          {If(show, () => (
+            <UniqueContent id={uuid} />
+          ))}
         </div>
       );
 
-      body.append(element as any);
+      body.append(element as unknown as HTMLElement);
       await runPendingSetupEffects();
 
-      let uniqueElement = body.querySelector('retend-unique-instance');
+      const uniqueElement = body.querySelector('retend-unique-instance');
       expect(uniqueElement?.getAttribute('state')).toBe('new');
 
       show.set(true);
       await runPendingSetupEffects();
 
       const uniqueElements = body.querySelectorAll('retend-unique-instance');
-      // During transition, there might be multiple elements temporarily
+
       expect(uniqueElements.length).toBeGreaterThan(0);
       const states = Array.from(uniqueElements).map((el) =>
         el.getAttribute('state')
@@ -481,25 +478,24 @@ describe('Unique', () => {
       const uuid = crypto.randomUUID();
       const saveStates: string[] = [];
 
-      const UniqueContent = () => {
-        return (
-          <Unique
-            name={uuid}
-            onSave={(el) => {
-              saveStates.push(el.getAttribute('state') || '');
-              return {};
-            }}
-          >
-            {() => <div>Unique Data</div>}
-          </Unique>
-        );
-      };
+      const UniqueContent = createUnique(() => <div>Unique Data</div>, {
+        onSave: (el: HTMLElement) => {
+          saveStates.push(el.getAttribute('state') || '');
+          return {};
+        },
+      });
 
       const { body } = window.document;
       const show = Cell.source(true);
-      const element = <div>{If(show, UniqueContent)}</div>;
+      const element = (
+        <div>
+          {If(show, () => (
+            <UniqueContent id={uuid} />
+          ))}
+        </div>
+      );
 
-      body.append(element as any);
+      body.append(element as unknown as Node);
       await runPendingSetupEffects();
 
       let uniqueElement = body.querySelector('retend-unique-instance');
@@ -527,7 +523,7 @@ describe('Unique', () => {
       let listenerCalls = 0;
       const sourceCell = Cell.source(0);
 
-      const Content = () => {
+      const UniqueContent = createUnique(() => {
         const derived = Cell.derived(() => {
           derivedComputes++;
           return sourceCell.get() * 2;
@@ -537,11 +533,7 @@ describe('Unique', () => {
         });
 
         return <div>{derived}</div>;
-      };
-
-      const UniqueContent = () => (
-        <Unique name={uuid}>{() => <Content />}</Unique>
-      );
+      });
 
       const page = Cell.source<'home' | 'about'>('home');
       const renderApp = Cell.source(true);
@@ -553,13 +545,13 @@ describe('Unique', () => {
               home: () => (
                 <div>
                   <h1>Home</h1>
-                  <UniqueContent />
+                  <UniqueContent id={uuid} />
                 </div>
               ),
               about: () => (
                 <div>
                   <h1>About</h1>
-                  <UniqueContent />
+                  <UniqueContent id={uuid} />
                 </div>
               ),
             })
@@ -568,7 +560,7 @@ describe('Unique', () => {
       );
 
       const { body } = window.document;
-      body.append((<App />) as any);
+      body.append((<App />) as unknown as HTMLElement);
       await runPendingSetupEffects();
 
       // 1. Initial state
@@ -613,19 +605,12 @@ describe('Unique', () => {
       const states: string[] = [];
       const saveStates: string[] = [];
 
-      const UniqueContent = () => {
-        return (
-          <Unique
-            name={uuid}
-            onSave={(el) => {
-              saveStates.push(el.getAttribute('state') || '');
-              return {};
-            }}
-          >
-            {() => <div>Unique Data</div>}
-          </Unique>
-        );
-      };
+      const UniqueContent = createUnique(() => <div>Unique Data</div>, {
+        onSave: (el: HTMLElement) => {
+          saveStates.push(el.getAttribute('state') || '');
+          return {};
+        },
+      });
 
       const { body } = window.document;
       const showFirst = Cell.source(true);
@@ -633,12 +618,18 @@ describe('Unique', () => {
 
       const element = (
         <div>
-          First: {If(showFirst, UniqueContent)} || Second:{' '}
-          {If(showSecond, UniqueContent)}
+          First:{' '}
+          {If(showFirst, () => (
+            <UniqueContent id={uuid} />
+          ))}{' '}
+          || Second:{' '}
+          {If(showSecond, () => (
+            <UniqueContent id={uuid} />
+          ))}
         </div>
       );
 
-      body.append(element as any);
+      body.append(element as unknown as Node);
       await runPendingSetupEffects();
 
       let uniqueElement = body.querySelector('retend-unique-instance');
@@ -683,46 +674,6 @@ describe('Unique', () => {
       body.replaceChildren();
     });
 
-    it('should preserve content even if new instance has different children function', async () => {
-      const renderer = getActiveRenderer() as DOMRenderer;
-      const { host: window } = renderer;
-      const uuid = crypto.randomUUID();
-
-      const { body } = window.document;
-      const showFirst = Cell.source(true);
-
-      const App = () => (
-        <div>
-          {If(
-            showFirst,
-            () => (
-              <Unique name={uuid}>
-                {() => <div id="orig">Original Content</div>}
-              </Unique>
-            ),
-            () => (
-              <Unique name={uuid}>
-                {() => <div id="new">New Content</div>}
-              </Unique>
-            )
-          )}
-        </div>
-      );
-
-      body.append((<App />) as any);
-      await runPendingSetupEffects();
-      expect(body.querySelector('#orig')).not.toBeNull();
-      expect(body.querySelector('#new')).toBeNull();
-
-      showFirst.set(false);
-      await runPendingSetupEffects();
-
-      // Should still have original content because it's "Unique" by name
-      expect(body.querySelector('#orig')).not.toBeNull();
-      expect(body.querySelector('#new')).toBeNull();
-      body.replaceChildren();
-    });
-
     it('should preserve and update attributes on the Unique wrapper', async () => {
       const renderer = getActiveRenderer() as DOMRenderer;
       const { host: window } = renderer;
@@ -730,16 +681,14 @@ describe('Unique', () => {
       const className = Cell.source('initial-class');
 
       const { body } = window.document;
-      const App = () => (
-        <Unique name={uuid} class={className}>
-          {() => <div>Content</div>}
-        </Unique>
-      );
+      const Component = createUnique(() => <div>Content</div>, {
+        container: { class: className },
+      });
 
-      body.append((<App />) as any);
+      body.append((<Component />) as unknown as Element);
       await runPendingSetupEffects();
 
-      let uniqueEl = body.querySelector('retend-unique-instance');
+      const uniqueEl = body.querySelector('retend-unique-instance');
       expect(uniqueEl?.className).toBe('initial-class');
 
       className.set('updated-class');
@@ -755,22 +704,18 @@ describe('Unique', () => {
       const innerUuid = `inner-${crypto.randomUUID()}`;
       const innerSetup = vi.fn();
 
-      const Inner = () => {
+      const Inner = createUnique(() => {
         useSetupEffect(() => {
           innerSetup();
         });
         return <div>Inner Content</div>;
-      };
+      });
 
-      const Outer = () => (
-        <Unique name={outerUuid}>
-          {() => (
-            <div class="outer-box">
-              <Unique name={innerUuid}>{() => <Inner />}</Unique>
-            </div>
-          )}
-        </Unique>
-      );
+      const Outer = createUnique(() => (
+        <div class="outer-box">
+          <Inner id={innerUuid} />
+        </div>
+      ));
 
       const { body } = window.document;
       const show = Cell.source(true);
@@ -778,10 +723,10 @@ describe('Unique', () => {
         (
           <div>
             {If(show, () => (
-              <Outer />
+              <Outer id={outerUuid} />
             ))}
           </div>
-        ) as any
+        ) as unknown as Node
       );
       await runPendingSetupEffects();
 
@@ -808,23 +753,23 @@ describe('Unique', () => {
       const uuid = crypto.randomUUID();
       const cleanupFn = vi.fn();
 
-      const Content = () => {
+      const Content = createUnique(() => {
         useSetupEffect(() => {
           return cleanupFn;
         });
         return <div>Content</div>;
-      };
+      });
 
       const { body } = window.document;
       const show = Cell.source(true);
       const app = (
         <div>
           {If(show, () => (
-            <Unique name={uuid}>{() => <Content />}</Unique>
+            <Content id={uuid} />
           ))}
         </div>
       );
-      body.append(app as any);
+      body.append(app as unknown as Node);
       await runPendingSetupEffects();
 
       expect(cleanupFn).not.toHaveBeenCalled();
@@ -841,6 +786,268 @@ describe('Unique', () => {
       expect(cleanupFn).toHaveBeenCalledTimes(1);
       body.replaceChildren();
     });
+
+    it('should pass props as a reactive Cell', async () => {
+      const renderer = getActiveRenderer() as DOMRenderer;
+      const { host: window } = renderer;
+      const uuid = crypto.randomUUID();
+      let receivedProps: any = null;
+
+      interface Props {
+        name: string;
+        value: number;
+      }
+
+      const UniqueWithProps = createUnique<Props>((props) => {
+        receivedProps = props;
+        return <div>Content</div>;
+      });
+
+      const { body } = window.document;
+      body.append(
+        (
+          <UniqueWithProps id={uuid} name="test" value={42} />
+        ) as unknown as Node
+      );
+      await runPendingSetupEffects();
+
+      expect(receivedProps).not.toBeNull();
+      expect(typeof receivedProps.get).toBe('function');
+      expect(receivedProps.get().name).toBe('test');
+      expect(receivedProps.get().value).toBe(42);
+      body.replaceChildren();
+    });
+
+    it('should update props reactively when component is re-rendered with new props', async () => {
+      const renderer = getActiveRenderer() as DOMRenderer;
+      const { host: window } = renderer;
+      const uuid = crypto.randomUUID();
+      const propValues: string[] = [];
+
+      interface Props {
+        name: string;
+      }
+
+      const UniqueWithProps = createUnique<Props>((props) => {
+        const name = Cell.derived(() => props.get().name);
+        name.listen((value) => {
+          propValues.push(value);
+        });
+        return <div>Name: {name}</div>;
+      });
+
+      const { body } = window.document;
+      const currentName = Cell.source('Alice');
+
+      const App = () => (
+        <div>
+          {If(currentName, (name) => (
+            <UniqueWithProps id={uuid} name={name} />
+          ))}
+        </div>
+      );
+
+      body.append((<App />) as unknown as Node);
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Name: Alice');
+
+      currentName.set('Bob');
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Name: Bob');
+      expect(propValues).toContain('Bob');
+
+      currentName.set('Charlie');
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Name: Charlie');
+      expect(propValues).toContain('Charlie');
+
+      body.replaceChildren();
+    });
+
+    it('should maintain prop reactivity when unique component moves between locations', async () => {
+      const renderer = getActiveRenderer() as DOMRenderer;
+      const { host: window } = renderer;
+      const uuid = crypto.randomUUID();
+
+      interface Props {
+        count: Cell<number>;
+        label: string;
+      }
+
+      const UniqueCounter = createUnique<Props>((props) => {
+        const count = Cell.derived(() => props.get().count.get());
+        const label = Cell.derived(() => props.get().label);
+        return (
+          <div>
+            {label}: {count}
+          </div>
+        );
+      });
+
+      const { body } = window.document;
+      const count = Cell.source(0);
+      const showInFirst = Cell.source(true);
+      const showInSecond = Cell.derived(() => !showInFirst.get());
+
+      const App = () => (
+        <div>
+          <div class="first">
+            {If(showInFirst, () => (
+              <UniqueCounter id={uuid} count={count} label="First" />
+            ))}
+          </div>
+          <div class="second">
+            {If(showInSecond, () => (
+              <UniqueCounter id={uuid} count={count} label="Second" />
+            ))}
+          </div>
+        </div>
+      );
+
+      body.append((<App />) as unknown as Node);
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body.querySelector('.first')!)).toBe('First: 0');
+
+      // Update count while in first position
+      count.set(5);
+      await runPendingSetupEffects();
+      expect(getTextContent(body.querySelector('.first')!)).toBe('First: 5');
+
+      // Move to second position
+      showInFirst.set(false);
+      await runPendingSetupEffects();
+      expect(getTextContent(body.querySelector('.second')!)).toBe('Second: 5');
+
+      // Update count while in second position
+      count.set(10);
+      await runPendingSetupEffects();
+      expect(getTextContent(body.querySelector('.second')!)).toBe('Second: 10');
+
+      // Move back to first position
+      showInFirst.set(true);
+      await runPendingSetupEffects();
+      expect(getTextContent(body.querySelector('.first')!)).toBe('First: 10');
+
+      body.replaceChildren();
+    });
+
+    it('should handle complex prop objects reactively', async () => {
+      const renderer = getActiveRenderer() as DOMRenderer;
+      const { host: window } = renderer;
+      const uuid = crypto.randomUUID();
+
+      interface User {
+        name: string;
+        age: number;
+      }
+
+      interface UserCardProps {
+        user: User;
+      }
+
+      const UserCard = createUnique<UserCardProps>((props) => {
+        const user = Cell.derived(() => props.get().user);
+        const name = Cell.derived(() => user.get().name);
+        const age = Cell.derived(() => user.get().age);
+        return (
+          <div>
+            {name} ({age})
+          </div>
+        );
+      });
+
+      const { body } = window.document;
+      const user = Cell.source({ name: 'Alice', age: 25 });
+
+      const App = () => (
+        <div>
+          {If(user, (user) => (
+            <UserCard id={uuid} user={user} />
+          ))}
+        </div>
+      );
+
+      body.append((<App />) as unknown as Node);
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Alice (25)');
+
+      user.set({ name: 'Bob', age: 30 });
+      await runPendingSetupEffects();
+      expect(getTextContent(body)).toBe('Bob (30)');
+
+      user.set({ name: 'Charlie', age: 35 });
+      await runPendingSetupEffects();
+      expect(getTextContent(body)).toBe('Charlie (35)');
+
+      body.replaceChildren();
+    });
+
+    it('should not recreate internal state when props change', async () => {
+      const renderer = getActiveRenderer() as DOMRenderer;
+      const { host: window } = renderer;
+      const uuid = crypto.randomUUID();
+      let setupCount = 0;
+
+      interface StatefulComponentProps {
+        label: string;
+      }
+
+      const StatefulComponent = createUnique<StatefulComponentProps>(
+        (props) => {
+          const internalState = Cell.source(0);
+
+          useSetupEffect(() => {
+            setupCount++;
+            internalState.set(100); // Set some initial state
+          });
+
+          const label = Cell.derived(() => props.get().label);
+
+          return (
+            <div>
+              {label}: {internalState}
+            </div>
+          );
+        }
+      );
+
+      const { body } = window.document;
+      const label = Cell.source('Label A');
+
+      const App = () => (
+        <div>
+          {If(label, (label) => (
+            <StatefulComponent id={uuid} label={label} />
+          ))}
+        </div>
+      );
+
+      body.append((<App />) as unknown as Node);
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Label A: 100');
+      expect(setupCount).toBe(1);
+
+      // Change props - should not recreate internal state or re-run setup
+      label.set('Label B');
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Label B: 100'); // internal state preserved
+      expect(setupCount).toBe(1); // setup not called again
+
+      label.set('Label C');
+      await runPendingSetupEffects();
+
+      expect(getTextContent(body)).toBe('Label C: 100'); // internal state still preserved
+      expect(setupCount).toBe(1); // setup still not called again
+
+      body.replaceChildren();
+    });
   });
 
   describe('VDom', () => {
